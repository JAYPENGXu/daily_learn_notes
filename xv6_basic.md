《xv6: a simple, Unix-like teaching operating system》

一、 操作系统接口（Operating system interfaces）

操作系统的工作是在多个程序之间共享一台计算机，并提供一个比硬件本身支持的更有用的服务集，操作系统在多个程序之间共享硬件资源，以便它们（看似）同时运行，操作系统为程序交互提供受控方式，以便它们可以共享数据或者协同工作。

<img src="G:\typora_image_store\image-20221216124255467.png" alt="image-20221216124255467" style="zoom:80%;" />

每个运行的程序称之为进程，由包含指令的内存，数据和栈组成。指令实行程序的计算，数据交由计算执行，栈管理程序的调度。当一个进程需要唤醒一个kernel服务，它就唤醒了一个system call，每个system call 进入内核，内核完成服务并返回。kernel使用了硬件保护机制提供给CPU，确保每个进程在自己的用户空间只能访问自己的内存。用户程序执行时没有这种特权，当一个用户程序唤醒一个系统调用时，硬件会提升权限并开始执行预先在内核中排序好的程序。内核提供的系统调用集合是用户程序看到的接口。

shell是一个原生的程序用来读取指令并执行。实际上，shell是一个用户程序，而不是内核的一部分。

1.1 processes and memory

xv6包含用户空间内存（指令、数据、栈），和内核私有的每个进程状态。当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程，内核通过PID连接每个进程。

`int fork()`：一个进程可以通过fork创建一个新的进程，提供相同的内存上下文包括指令和数据，但内存地址和寄存器是不一样的，父进程返回子进程的PID，子进程返回0。

```c
int pid = fork();  //fork之后，父子进程同时开始判断pid的值，看哪个进程先判断好pid才会决定输出顺序。
printf("pid=%d\n", pid);
if(pid > 0){
	printf("parent: child=%d\n", pid);
	pid = wait((int *) 0); //父进程发现子进程exit之后，wait执行完毕，打印输出。
	printf("child %d is done\n", pid);
} else if(pid == 0){
	printf("child: exiting\n");
	exit(0);  //子进程在判断pid==0之后将exit,
} else {
	printf("fork error\n");
}

---
输出：
pid=2018356
parent:child=2018356
pid=0
child:existing
child 2018356 is done  //当子进程退出后，父进程的wait就会返回。

```

`int exit(int status)`: 系统调用会停止执行并释放资源,如内存和打开的文件,需要一个整型的状态参数，返回值0表示正常状态退出，1表示非正常状态退出。

`int wait(int *status)`：系统调用返回当前进程被停止或被杀掉的子进程的状态，返回子进程的PID， 子进程的退出状态存储到 int *status这个地址中，并将状态码拷贝到内存中等待。如果调用者没有子进程，wait立即返回-1，如果父进程不在乎子进程的退出态，它可以给一个0地址给wait。父进程和子进程有着相同的内存上下文，但是在不同的内存和寄存器中执行。改变一个并不会改变另一个。如当wait的返回值被父进程存储到pid中时，它不会改变子进程中变量pid中的值，子进程中的变量pid的值还是0。

`int exec(char *file, char *argv[])`:加载一个文件，获取执行它的参数，执行，如果执行错误返回-1，执行成功不返回，而是开始从文件入口位置开始执行命令。文件必须有一个特殊的格式，必须指明哪一部分是保存指令，哪一部分是数据。xv6使用的是ELF文件格式，当exec成功时，他不会返回给调用程序，相反，从文件加载的指令在 ELF 标头中声明的入口点开始执行。exec输入两个参数：文件包含的可执行文件名和一组参数。

```c
//xv6 shell使用以上四个system call来为用户执行程序。在shell进程的main中主循环先通过getcmd来从用户获取命令，然后调用fork来运行一个和当前shell进程完全相同的子进程。父进程调用wait等待子进程exec执行完（在runcmd中调用exec）

char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
//---------------------------------------------------
int main(){
    static char buf[100];
    int fd;
    // ensure that three file descriptions are open.
    while(fd = open("console", O_RDWR ) >= 0){
        if(fd >= 3){
            close(fd);
            break;
        }
    }
    // read and run input commands
    while(getcmd(buf, sizesof(buf)) >= 0){
        if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
            // chdir must be called by the parent, not the child.
            buf[strlen(buf) - 1] = 0;
            if(chdir(buf + 3) < 0)
                fprintf(2, "cannot cd %s\n", buf + 3);
            continue;
        }
        if(fork1() == 0)
            runcmd(parsecmd(buf));
        wait(0);
    }
    exit(0);
}
```

避免创建重复进程然后立即替换它的浪费,操作内核通过使用虚拟内存技术（如写时复制 copy-on-write）优化此用例的 fork 实现。xv6 隐式分配大部分用户空间内存：fork 分配父内存的子副本所需的内存，exec 分配足够的内存来保存可执行文件。在运行时需要更多内存的进程（可能是 `malloc`）可以调用 `sbrk(n)` 将其数据内存增加 n 字节； `sbrk` 返回新内存的位置。

1.2 输入输出和文件描述符 (I/O and file descriptors)

文件描述符是用来表征一个进程将从哪里读取或者写入到哪里的内核管理对象。一个进程可以通过打开一个文件、目录或设备或创建一个管道，或复制一个已经存在的描述符。文件描述符接口抽象了文件、管道和设备之间的差异，使它们看起来都像字节流。xv6 内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符的私有空间。每个进程都拥有自己独立的文件描述符列表，**其中0是标准输入，1是标准输出，2是标准错误**。shell将保证总是有3个文件描述符是可用的。

`int read(int fd, char * buf, int n)`; 从文件描述符fd中读取n字节的数据拷贝到buf中，**返回值是读取的字节数**。每个文件描述符都有一个与之相关的offset。read 从当前文件偏移量读取数据，然后将该偏移量增加读取的字节数，下一个read将从新的offset开始读取字节，当没有更多的字节可以读取时，read返回0来表示读取到文件的结束。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

#define MSGSIZE 16
int main(int argc, char * argv[]){
    char buf[MEGSIZE];
    read(0, buf, MSGSIZE); //获取前一个命令的标准化输出，即当前命令的标准化输入
    printf("获取到的标准化输入:%s\n", buf);
    exit(0);
}
```

`int write(int fd, char *buf,int n)`；从buf中写入n字节的数据到文件描述符fd中，返回值是有多少的字节数据被写入。当少于n个字节的数据被写入时互出现错误，通read一样存在偏移量。

```c
//cat命令的实现
char buf[512];
int n;
for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0) break;
    if(n < 0){
        fprintf(2, "read error\n");
        exit(1);
    }
    if(write(1, buf, n) != n){
        fprintf(2, "write error\n");
        exit(1);
    }
}
```

`int close(int fd)`:系统调用，释放一个文件描述符，让它变得可以被未来的open pipe 或者dup系统调用使用。

fork拷贝父进程的文件描述符到自己的内存空间中，因此子进程可以像父进程一样打开文件，exec代替了调用进程的内存，但是将它保留在文件表中。父进程的fd table将不会被子进程fd table的变化影响，但是文件中的offset将被共享。

```c
// cat 命令的实现 cat < input.txt
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0){
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```

关键字： O_RDONLY：打开文件for reading, OWRONLY:打开文件for writting, , ORDWR:打开文件for reading and writting , O_CREATE:如果文件不存在，就创造它, O_TRUNC：将文件截断到0的长度。

`int dup(int fd)`:系统调用，返回一个引用相同底层 I/O 对象的新对象。两个文件描述符共享一个偏移量，就像 fork 复制的文件描述符一样。

```c
// another way to write hello world
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

如果两个文件描述符是通过一系列 fork 和 dup 调用从同一个原始文件描述符派生的，则它们共享一个偏移量,否则文件描述符不共享偏移量，即使它们来自对同一文件的打开调用。dup 允许shell去实现一个这样的命令： ls existing-file non-existing-file > tmp1 2 >&1, 2>&1 告诉 shell 给命令一个文件描述符 2，它是描述符 1 的副本。现有文件的名称和不存在文件的错误消息都将显示在文件 tmp1 中.xv6 shell 不支持错误文件描述符的 I/O 重定向，但现在你知道如何实现它了。

1.3管道

管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。将数据写入管道的一端使该数据可用于从管道的另一端读取。 管道为进程提供了一种通信方式。（FIFO实现）

`int pipe(int p[])`:p[0]为读取的fd,p[1]为写入的fd。

```c
//以下示例代码运行程序 wc，标准输入连接到管道的读取端。
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0){
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
}else {
    close(p[0]);
    write(p[1], "hello world\n", 12);
    close(p[1]);
}
//这段程序叫做pipe，它创造了一个新的管道来记录读和写的文件描述符在数组p中。在fork之后，父进程和子进程都会有文件描述符指向这个管道，子进程调用close和dup来让文件描述符0引用管道的读取端，关闭文件描述符，之后调用exec执行wc指令，当wc读取它的标准输入时，它从管道读取，父进程关闭了管道的读取端，写管道，然后关闭写端。
```

如果没有数据可用，则管道上的读取等待写入数据或关闭引用写入端的所有文件描述符； 在后一种情况下，read 将返回 0，就像已到达数据文件的末尾一样。 读取阻塞直到新数据不可能到达的事实是子进程在执行上面的 wc 之前关闭管道的写入端很重要的一个原因：如果 wc 的文件描述符之一引用了写入端管道，wc永远看不到文件结束。

xv6的shell实现一个这样的命令： `grep fork sh.c | wc -l`，子进程创建一个管道来连接管道的左端和右端。之后在管道左端调用fork和runcmd指令，在管道右端调用fork和runcmd指令，然后等待两边都结束。管道的右端可能是一个命令，它本身包含一个管道（例如，a | b | c），它本身会派生两个新的子进程（一个用于 b，一个用于 c）。因此，shell 可以创建一个进程树。这棵树的叶子节点是命令，内部节点是等待左右子节点完成的进程。原则上，可以让内部节点运行在管道的左端，但如果这样做正确的话会使实施变得复杂。考虑仅进行以下修改：
将 sh.c 更改为不分叉 p->left 并在内部进程中运行 runcmd(p->left)。之后例如：`echo hi | wc`不会产生输出，因为在runcmd中echo hi退出时，内部进程退出，从不调用fork运行右端管道,这种不正确的行为可以通过不在 runcmd 中为内部进程调用 exit 来修复，但此修复使代码复杂化：现在 runcmd 需要知道它是否在内部进程中。当不分叉 runcmd(p->right) 时也会出现并发症。例如，仅进行该修改，`sleep 10 | echo hi` 将立即打印“hi”和一个新提示，而不是在 10 秒后； 发生这种情况是因为 echo 立即运行并退出，而不是等待 sleep 完成。由于 sh.c 的目标是尽可能简单，它不会试图避免创建内部进程。

在这种情况下，管道比临时文件至少有四个优势。第一：管道会自动清理自己，使用文件重定向，shell必须小心删除/tmp/xyz当它执行完成后。其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三、管道允许管道并行执行阶段，而文件方法要求第一个程序在第二个程序开始之前完成。 第四，如果你正在实现进程间通信，管道的阻塞读写比文件的非阻塞语义更高效。

1.4文件系统

xv6 文件系统提供数据文件，其中包含未解释的字节数组（byte array）和目录，其中包含对数据文件和其他目录的命名引用。这些目录形成一棵树，从称为root的特殊目录开始。不以 / 开头的路径是相对于调用进程的当前目录进行评估的（相对路径），该目录可以通过 chdir 系统调用进行更改。这两个代码片段都打开同一个文件（假设所有涉及的目录都存在)。

```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);
open("/a/b/c", O_RDONLY);
//第一个片段将进程的当前目录更改为/a/b； 第二个既不引用也不更改进程的当前目录。
```

有创建新文件和目录的系统调用：`mkdir` 创建新目录，使用 O_CREATE 标志打开创建新数据文件，`mknod` 创建新设备文件。 这个例子说明了所有三个：

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod` 创建一个引用设备的特殊文件,与设备文件相关联的是主设备号（major device）和次设备号(minor device),通过这两个参数唯一的确定这个设备，mknod 的两个参数，它们唯一地标识内核设备。当进程稍后打开设备文件时，内核将read和write系统调用转移到这个内核设备上，而不是将它们传递给文件系统。

文件名与文件本身不同； 同一个底层文件，称为索引节点（inode），可以有多个名称，称为links。每个链接都包含目录中的一个条目； 该条目包含一个文件名称和对 inode 的引用。inode 保存有关文件的元数据，包括其类型（文件或目录或设备）、长度、文件内容在磁盘上的位置以及文件的链接数。

`int fstat(int fd, struct stat *st)` ：系统调用从文件描述符**fd**引用的 inode 检索信息，将inode中的相关信息存储到**st**中。执行成功返回0， 失败返回-1。在 stat.h (kernel/stat.h) 中定义为：

```c
#define  T_DIR 1
#define T_FILE 2
#define T_DEVICE 3
struct stat{
    int dev; //file system's disk device
    uint ino; //inode number
    short type; //type of file
    short nlink; // number of links to file
    uint64 size; //size of file in bytes
};
```

`link`:系统调用，创建一个指向同一个inode的文件名。`unlink`则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时，这个inode以及其存储的文件内容才会被从硬盘上移除。 此片段创建一个名为 a 和 b 的新文件。

```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

从 a 读取或写入 a 与从 b 读取或写入相同。每个 inode 都由唯一的 inode 编号标识。在上面的代码执行之后，可以通过检查 fstat 的结果来确定 a 和 b 引用相同的底层内容：两者都将返回相同的 inode 号（ino），并且 nlink 计数将设置为 2.unlink 系统调用从文件系统中删除一个名称。 只有当文件的链接计数为零并且没有文件描述符引用它时，文件的索引节点和保存其内容的磁盘空间才会被释放。 从而添加 unlink("a")；到最后一个代码序列使 inode 和文件内容可访问为 b。

```c
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

以上代码是创建一个没有名称的临时 inode 的惯用方法，当进程关闭 fd 或退出时将被清理。

Unix 提供可从 shell 调用的文件实用程序作为用户级程序，例如 `mkdir`、`ln` 和 `rm`等。这种设计允许任何人通过添加新的用户级程序来扩展命令行界面。事后看来，这个计划似乎很明显，但在 Unix 时代设计的其他系统通常将此类命令内置到 shell 中（并将 shell 内置到内核中）。一个例外是 cd，它内置于 shell (user/sh.c:160) 中。 cd 必须更改 shell 本身的当前工作目录。 如果 cd 作为常规命令运行，则 shell 将派生一个子进程，子进程将运行 cd，而 cd 将更改子进程的工作目录。 父级（即 shell 的）工作目录不会改变。

1.5 Real world

Unix 将“标准”文件描述符、管道和用于操作它们的方便的 shell 语法相结合，这是编写通用可重用程序的重大进步。 这个想法引发了一场 “软件工具”文化,也是 Unix 强大和流行的主要原因，而 shell 是第一个所谓的“脚本语言”。 Unix 系统调用接口今天在 BSD、Linux 和 macOS 等系统中仍然存在。Unix 系统调用接口已通过可移植操作系统接口 (POSIX) 标准进行了标准化。xv6 不符合 POSIX：它缺少许多系统调用（包括基本的系统调用，例如 lseek），并且它提供的许多系统调用与标准不同。 xv6 的主要目标是简单明了，同时提供简单的类 UNIX 系统调用接口。 为了运行基本的 Unix 程序，一些人用更多的系统调用和一个简单的 C 库扩展了 xv6。然而，与 xv6 相比，现代内核提供了更多的系统调用和更多种类的内核服务。 例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。 现代内核不断快速发展，并提供许多超越 POSIX 的功能。

Unix 使用一组文件名和文件描述符接口统一访问多种类型的资源（文件、目录和设备）。 这个想法可以扩展到更多种类的资源；一个很好的例子是Plan 9，它将“资源是文件”的概念应用于网络、图形等。然而，大多数 Unix 派生的操作系统并没有遵循这条路线。

文件系统和文件描述符是强大的抽象。 即便如此，还有其他操作系统接口模型。 Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，从而产生了一种截然不同的界面风格。 Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图构建更简单的东西。

Xv6 不提供用户或保护一个用户免受另一个用户侵害的概念； 在 Unix 术语中，所有 xv6 进程都以 root 身份运行。

1.6 Exercises

“乒乓”：创建两个进程在管道的两端，父进程发送字节到子进程，子进程接收到字节打印自己的pid和recevied ping，然后通过管道写字节到父进程，父进程接收到后打印pid和recevied pong然后退出。

```c
#include"kernel/types.h"
#includeuser/user .h"
const int MESSAGE_SIZE = 7;
int main(int argc, char *argv[]){
    int fd[2];
    char buf[MESSAGE_SIZE];
    pipe(fd);
    int pid = fork();
    if(pid > 0){
        write(fd[1], "114514", 6);
        read(fd[0], buf, 6);
        printf("%d: received pong\n", getpid());
        exit(0);
    }else{
        read(fd[0], buf, 6);
        printf("%d: received ping\n", getpid());
        write(fd[1], "114514", 6);
        exit(0);
    }
}
```

素数筛法：使用pipe和fork实现流水线，将一组数范围为2到35喂入到一个进程中，先打印出最小的一个数，这个数是素数，之后用其他的数来除这个素数，如果可以整除则将其drop，不能整除的喂入到下一个进程，直到打印出所有的素数。





实现find：使用递归的方式找到指定的文件夹下的目标文件，参考user/ls.c实现方法：

```c
// hints:1.
struct dirent {
    ushort inum;
    char name[DIRSIZE];
}
//hints:2.
void *memmove(void *str1, const void *str2, size_t n);//从str2复制n个字符到str1，返回一个指向目标存储区str1的指针。
```





实现xargs：

`xargs`的作用是把stdin中的数据用空格或回车分割成命令行参数

例：`find .-name '*.py' | xargs cat | wc -l` :统计当前目录下所有python文件的总行数





二、operating system organization

2.1 Abatracting physical resources

​       在这个计划中，每个应用程序甚至可以有自己的库来满足其需求。应用程序可以直接与硬件资源交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能或可预测的性能）。一些嵌入式设备的操作系统或者实时的操作系统就是以这种方式运行。这种库方法的缺点是，如果有多个应用程序在运行，则这些应用程序必须运行良好。例如：每个应用程序必须周期性的放弃对CPU资源的使用以便于其它程序可以调用。如果每个程序都足够相信对方并且没有bug这样的合作的时分复用机制可以很OK的工作。但是没有bug和相信对方是难以实现的，因此一个比这个方案提供更强的隔离方案需要被提出。

```c
*ip += 1;//将ip指向的变量加1，相当于 ++*ip, 或（*ip)++。
//一元操作符从右向左结合，所以*ip++相当于*(ip++)
//指针的大小比较：只有在两个指针指向同一个数组的元素时比较才合法，指针只有相减是合法的
```

C程序的内存分配方案： 堆（heap）由程序员通过malloc和free控制，地址从低向高增长；栈（stack）编译器自动分配释放，存放函数的参数、局部变量的值，在退出函数后自动销毁释放，地址从高向低增长。	

实现一个强隔离性的方案将资源抽象成服务，对于禁止应用程序直接访问敏感的硬件资源是非常有用的。如unix程序和存储的交互通过文件系统的open、read、write和close系统调用，而不是直接读写磁盘。这为应用程序提供了路径名的便利，并允许操作系统（作为接口的实现者）管理磁盘。即使隔离不是问题，有意交互（或只是希望彼此远离）的程序也可能会发现文件系统是比直接使用磁盘更方便的抽象。

类似地，Unix 透明地在进程之间切换硬件 CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道时间共享。 这个透明度允许操作系统共享 CPU，即使某些应用程序处于无限状态循环。
​	另一个例子是，unix使用exec系统调用来构建自己的内存映像来代替直接和物理内存交互。这允许操作系统来决定在内存的哪里放置一个进程。如果内存紧张，操作系统内甚至可能会将进程的数据存储在磁盘上，exec还提供给用户一个方便的文件系统用来存储可执行的程序映像。
​	Unix 进程之间的许多形式的交互都是通过文件描述符发生的。 文件描述符不仅抽象出许多细节（例如，管道或文件中数据的存储位置），它们还以简化交互的方式定义。 例如，如果管道中的一个应用程序执行失败，内核会为管道中的下一个进程生成文件结束信号。

2.2 用户模式、超级模式、和系统调用

​	强隔离的实现需要在程序和系统调用之间有一个坚硬的边界。如果程序出错我们不希望操作系统和其他程序出现差错。而是希望操作系统能够清理这些出错的程序并继续执行其他的程序。为了实现这样的强隔离，操作系统必须安排让应用程序不能修改或读取操作系统的数据，并且应用程序不能访问其他的程序的内存。

​	CPU提供了这样的硬件支持。如RISC-V有三种让CPU执行的模式：machine mode, supervisor mode, user mode。在machine mode拥有最高的执行权力，CPU从该模式启动。用来配置计算机。XV6只在该模式下执行少量的程序然后切换到supevisor mode。

​	在supervisor mode下，CPU允许执行拥有特权的指令，例如：使能/失能中断，读写存储有page table的寄存器的值。如果应用程序在user mode想要执行特权的指令，CPU会禁止执行。一个应用程序只有在user mode下执行，如执行++i操作，在用户空间（user space）执行。在superivsor mode下执行的程序我们称之为运行在核空间（kernel space）。

一个用户态的程序想要唤醒一个核函数必须先进入到核空间，不能直接唤醒一个核函数。CPU 提供了一条特殊的指令，可以将 CPU 从用户模式（user mode）切换到管理员模式(supervisor mode)，并在内核指定的入口点进入内核（RISC-V提供了`ecall`指令用来完成这样的任务，ecall指令：跳转到trampoline代码）。一旦CPU切换到supervisor mode，内核就会验证这些系统指令的参数（例如，检查传递给系统调用的地址是否是应用程序内存的一部分）从而决定是否允许应用程序执行请求的操作（例如，检查是否允许应用程序写入指定的文件），然后决定是拒绝它或执行它。内核控制转换到管理模式的入口点很重要； 例如，如果应用程序可以决定内核入口点，则恶意应用程序可以在跳过参数验证的位置进入内核。

2.3 kernel organization

一个关键的问题是操作系统在管理者模式下该运行什么程序。一种可能是整个操作系统驻留在内核中，因此所有的系统调用的实现都运行在管理者模式。这种模式称为单片内核（monolithic kernel）。在这种形势下，整个操作系统拥有整个的硬件权限。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要完整的硬件特权。此外，操作系统的不同部分更容易协作。例如，操作系统可能有一个缓冲区缓存，它可以由文件系统和虚拟内存系统共享。这种组织的一个缺点是操作系统不同部分之间的接口通常很复杂，因此操作系统开发人员很容易犯错误。然而在这种模式下，一个错误的发生就会是致命的，因为在supervisor mode下的一个错误往往会导致内核失败，从而导致计算机停止工作。

​	为了降低内核出错的风险，操作系统设计人员可以最大限度地减少在管理员模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。 这种内核组织称为微内核（micro kernel）。

<img src="G:\typora_image_store\image-20221222135547484.png" alt="image-20221222135547484" style="zoom:80%;" />

在图中，文件系统作为用户级进程运行。 作为进程运行的操作系统服务称为服务器。 为了允许应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，可以将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像 shell 这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应。在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。

​	在现实世界中，单体内核和微内核都很流行。 许多 Unix 内核是单一的。 例如，Linux 有一个单一的内核，尽管一些操作系统功能作为用户级服务器运行（例如，窗口系统）。 Linux 为操作系统密集型应用程序提供高性能，部分原因是内核的子系统可以紧密集成。 Minix、L4 和 QNX 等操作系统被组织为带有服务器的微内核，并且在嵌入式设备中得到了广泛部署。 L4 的变体 seL4 足够小，以至于它已经过内存安全和其他安全属性的验证。操作系统的开发人员之间存在很多争论，认为哪种组织更好，并且没有任何一种方式的确凿证据。 此外，它在很大程度上取决于“更好”的含义：更快的性能、更小的代码大小、内核的可靠性、整个操作系统（包括用户级服务）的可靠性等。还有一些实际考虑可能比哪个组织的问题更重要。 一些操作系统有一个微内核，但出于性能原因，在内核空间中运行一些用户级服务。 一些操作系统具有整体内核，因为它们是这样开始的，并且没有动力转向纯微内核组织，因为新功能可能比重写现有操作系统以适应微内核设计更重要。

​	与大多数 Unix 操作系统一样，Xv6 是作为一个整体内核实现的。 这样，xv6内核接口对应操作系统接口，内核实现了完整的操作系统。 由于 xv6 不提供很多服务，它的内核比一些微内核更小，但概念上 xv6 是整体的。

2.4 XV6 organization

<img src="G:\typora_image_store\image-20221222151954835.png" alt="image-20221222151954835" style="zoom:80%;" />

trampoline.S(汇编代码)

* 对ecall瞬间的状态做快照
  * 填充struct trapframe (proc.h)
  * 利用\$sscratch(S-mode scratch) 保存所有寄存器
  * 切换到内核栈（相当于切换到进程对应的“内核线程”）
  * 切换到内核地址空间
  * 跳转到tf->kernel_trap

2.5 Process overview

xv6（和其他 Unix 操作系统一样）中的隔离单元是一个进程。进程抽象防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核本身，这样进程就无法破坏内核的隔离机制。内核必须小心地实现进程抽象，因为错误或恶意应用程序可能会诱使内核或硬件做一些坏事（例如，规避隔离）。内核用于实现进程的机制包括用户/管理员模式标志、地址空间和线程的时间片。

​	为了帮助加强隔离，进程抽象为程序提供了它拥有自己的私有机器的错觉。一个进程为程序提供了一个看似私有的内存系统或地址空间，其他进程无法读取或写入。 一个进程还为程序提供似乎是它自己的 CPU 来执行程序的指令。

​	xv6 使用page table（由硬件实现）为每个进程提供自己的地址空间。 RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换（或“映射”）为物理地址（CPU 芯片发送到主内存的地址）。

​	xv6 为每个定义进程地址空间的进程维护一个单独的页表。 如图 2.3 所示，地址空间包括从虚拟地址零开始的进程的用户内存。首先是指令，然后是全局变量，然后是堆栈，最后是进程可以根据需要扩展的“堆”区域（用于 malloc）。 有许多因素会限制进程地址空间的最大大小：RISC-V 上的指针是 64 位宽； 硬件在页表中查找虚拟地址时只使用低 39 位； 而 xv6 只使用了这 39 位中的 38 位。因此，最大地址为 $2^{38}$ − 1 = 0x3fffffffff，即MAXVA。在地址空间的顶部，xv6 保留了一个页面用于 trampoline 和一个映射进程的 trapframe 的页面。xv6 使用这两个页面来回转换到内核； trampoline 页面包含进出内核的代码，映射 trapframe 是保存/恢复用户进程状态所必需的.

​	xv6 内核为每个进程维护许多状态，并将其收集到一个 struct proc 中。进程最重要的内核状态部分是它的页表、内核堆栈和运行状态。 我们将使用符号 p->xxx 来指代 proc 结构的元素； 例如，p->pagetable 是指向进程页表的指针。

​	每个进程都有一个执行线程（或简称线程）来执行进程的指令。 一个线程可以被挂起并稍后恢复。为了在进程之间透明地切换，内核挂起当前运行的线程并恢复另一个进程的线程。 线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的堆栈中。每个进程都有两个栈：**用户栈**和**内核栈**（p->kstack）。 当进程在执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核时（系统调用或中断），内核代码在进程的内核栈上执行； 当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，但不会被主动使用。进程的线程在主动使用其用户堆栈和内核堆栈之间交替。 内核堆栈是独立的（并且不受用户代码的影响），因此即使进程破坏了其用户堆栈，内核也可以执行。
​	进程可以通过执行RISC-V 的`ecall`指令进行系统调用。该指令提高硬件特权级别并将程序计数器更改为内核定义的入口点。入口点的代码切换到内核堆栈并执行完成系统调用的内核指令。当系统调用完成后护内核切换回用户栈，通过调用`sret`指令返回用户空间，降低硬件的特权级别，恢复执行系统调用指令的用户指令。进程的线程可以在内核中“阻塞”以等待I/O, 并在I/O完成后从中断恢复。

​	p->state 表示进程是否已分配、准备运行、运行、等待 I/O 或退出。

​	p->pagetable 以 RISC-V 硬件期望的格式保存进程的页表。

​	xv6 导致分页硬件在用户空间中执行该进程时使用该进程的 p->pagetable。 一个进程的页表同时也记录了分配给进程内存的物理页的地址。

​	总而言之，一个进程捆绑了两种设计思想：地址空间让进程产生自己内存的错觉，线程让进程产生自己的 CPU 错觉。 在 xv6 中，一个进程由一个地址空间和一个线程组成。 在真实的操作系统中，一个进程可能有多个线程来利用多个 CPU。

2.6 starting xv6, the first process and system call

​	为了使 xv6 更具体，我们将概述内核如何启动和运行第一个进程。 后续章节将更详细地描述本概述中出现的机制。

​	当 RISC-V 计算机开机时，它会自行初始化并运行存储在只读存储器中的引导加载程序。 引导加载程序将 xv6 内核加载到内存中。 然后，在机器模式下，CPU 从 _entry (kernel/entry.S:7) 开始执行 xv6。 RISC-V 从禁用分页硬件开始：虚拟地址直接映射到物理地址。

​	加载程序将 xv6 内核加载到物理地址 0x80000000 的内存中。 它将内核放在 0x80000000 而不是 0x0 的原因是因为地址范围 0x0:0x80000000 包含 I/O 设备。

​	_entry 处的指令设置了一个堆栈，以便 xv6 可以运行 C 代码。 xv6 在文件 start.c 中为初始堆栈 stack0 声明了空间。 _entry 处的代码将堆栈指针寄存器 sp 加载到地址 stack0+4096，堆栈的顶部，因为 RISC-V 上的堆栈向下增长。 现在内核有了堆栈，entry 在开始时调用 C 代码。

​	函数 `start` 执行一些只允许在机器模式下进行的配置，然后切换到管理员模式。 为了进入管理模式，RISC-V 提供了指令 `mret`。 这个指令最常用于从先前的管理模式调用返回到机器模式。 start 不会从这样的调用中返回，而是将事情设置为好像有一个：它在寄存器 mstatus 中将先前的特权模式设置为主管，它通过将 main 的地址写入寄存器 mepc 来将返回地址设置为 main ，通过将 0 写入页表寄存器 satp 来禁用管理员模式下的虚拟地址转换，并将所有中断和异常委托给管理员模式。

​	在进入管理模式之前，start还执行一项任务，它对时钟芯片进行编程以生成定时器中断。完成这些任务处理后，通过调用mret开始“返回”到管理模式，这会导致程序计数器更改为main。在main初始化几个设备核子系统后，通过调用userinit创建第一个进程，第一个进程执行一个用RISC-V汇编编写的小程序，make进行xv6中的第一个系统调用，initcode.S将exec系统调用的编号SYS_EXEC加载到寄存器a7当中，然后调用ecall重新进入内核。

​	内核在系统调用中使用寄存器`a7`中的数字来调用所需的系统调用。系统调用将SYS_EXEC映射到内核调用的sys_exec。正如我们在第一章中看到的，exec用一个新程序代替了当前进程的内存和寄存器。

​	一旦内核完成exec之后，它就会在/init进程中返回到用户空间。如果需要，init会创建一个新的控制台设备文件，然后将其作为文件描述符0，1，2打开。然后它会在控制台上启动一个shell，此时系统就被启动了。

```
RISC-V启动时，先运行一个存储于ROM中的bootloader程序kernel.ld来加载xv6 kernel到内存中，然后在machine模式下从_entry开始运行xv6。bootloader将xv6 kernel加载到0x80000000的物理地址中，因为前面的地址中有I/O设备

在_entry中设置了一个初始stack，stack0来让xv6执行kernel/start.c。在start函数先在machine模式下做一些配置，然后通过RISC-V提供的mret指令切换到supervisor mode，使program counter切换到kernel/main.c

main先对一些设备和子系统进行初始化，然后调用kernel/proc.c中定义的userinit来创建第一个用户进程。这个进程执行了一个initcode.S的汇编程序，这个汇编程序调用了exec这个system call来执行/init，重新进入kernel。exec将当前进程的内存和寄存器替换为一个新的程序(/init)，当kernel执行完毕exec指定的程序后，回到/init进程。/init(user/init.c)创建了一个新的console device以文件描述符0,1,2打开，然后在console device中开启了一个shell进程，至此整个系统启动了
```

2.7 security model

您可能想知道操作系统如何处理错误或恶意代码。 因为处理恶意比处理意外错误要难得多，所以将这个主题视为与安全有关。 这是操作系统设计中典型安全假设和目标的高级视图。

​	操作系统必须假定进程的用户级代码会尽最大努力来破坏内核或其他进程。用户代码可能会尝试取消引用其与允许地址空间之外的指针空间，他可能会尝试执行任何RISC-V指令。即使是那些不打算用于用户代码的指令，他可能会尝试读写任何RISC-V控制寄存器，他可能会尝试直接访问设备硬件，他可能会将巧妙地值传递给系统调用，以试图诱使内核崩溃或做一些愚蠢的事情。内核的目标是限制每个用户进程，以便所有它可以做的事read/write/execute自己的用户内存。使用32位通用RISC-V寄存器，并以系统调用旨在允许的方式影响内核和其他进程。内核必须阻止任何其他操作，这通常事内核设计中的绝对要求。

​	对内核自身代码的期望是完全不同的。 内核代码被假定是由善意和细心的程序员编写的。 内核代码应该没有错误，当然也不包含任何恶意内容。 这个假设会影响我们分析内核代码的方式。 例如，有许多内部内核函数（例如自旋锁）如果内核代码使用不当会导致严重问题。 在检查任何特定的内核代码时，我们想要说服自己它的行为是正确的。 然而，我们假设内核代码通常是正确编写的，并且遵循关于使用内核自己的函数和数据结构的所有规则。 在硬件层面，假定 RISC-V CPU、RAM、磁盘等按照文档中宣传的方式运行，没有硬件错误.

​	当然，在现实生活中的事情并没有那么简单，很难防止聪明的用户代码通过消耗内核保护的资源（磁盘空间、CPU时间、进程表等）使系统无法使用或崩溃。通常不可能编写没有错误的代码，如果恶意用户代码的编写者直到内核或硬件错误，他们就会利用这些漏洞。值得在内核中设计安全措施以防止它有错误的可能性：断言、类型检查、堆栈保护页面等。

2.8 real word

​	大多数操作系统都采用了进程的概念，而且大多数进程看起来与 xv6 的类似。 然而，现代操作系统支持一个进程中的多个线程，以允许单个进程利用多个 CPU。 在一个进程中支持多个线程涉及 xv6 所没有的相当多的机制，包括潜在的接口更改（例如，Linux 的克隆，fork 的变体），以控制进程线程共享的哪些方面。

2.9 experiment

1. 在xv6中添加一个系统调用并返回还有多少可用的内存空间的大小。





三、 page tables

页表是最流行的机制，操作系统通过它为每个进程提供自己的私有地址空间和内存，从而实现内存隔离。页表决定了内存地址空间的含义，以及可以访问物理内存的哪些部分。它们允许xv6隔离不同进程的地址空间并将它们多路复用到单个物理内存中。页表是一种流行的设计，因为它们提供了一种允许操作系统执行一些小trick的执行方式。xv6执行一些技巧，在多个地址空间中映射相同的内存，并使用未映射的页面保护内核和用户堆栈。

3.1 paging hardware

作为提醒，RISC-V 指令（用户和内核）操作虚拟地址。 机器的 RAM 或物理内存是用物理地址索引的。 RISC-V 页表硬件通过将每个虚拟地址映射到物理地址来连接这两种地址。

​	xv6 运行在 Sv39 RISC-V 上，这意味着只使用 64 位虚拟地址的低 39 位； 前 25 位未使用。在这个Sv39配置中，RISC-V页表在逻辑上是一个包含$2^{27}$（134217728）个页表条目（PTE）的数组。每个PTE包含一个44bit的物理页码（PPN）和一些标志。分页硬件使用前27位转换虚拟地址，将39位中的bit索引到页表中找到一个PTE，并制作一个56位的物理地址，其高44位来自PTE中的PPN，低12位是从PTE中复制的原始虚拟地址。图 3.1 将页表的逻辑视图显示为一个简单的 PTE 数组（有关更完整的故事，请参见图 3.2）。 页表使操作系统能够以 4096 ($2^{12}$) 字节的对齐块的粒度对虚拟地址到物理地址的转换进行控制。 这样的块称为 *page*。

<img src="G:\typora_image_store\image-20221223151555612.png" alt="image-20221223151555612" style="zoom:80%;" />

​	在 Sv39 RISC-V 中，虚拟地址的前 25 位不用于转换。 物理地址也有增长的空间：PTE 格式中有空间让物理页号再增长 10 位。 RISC-V 的设计者根据技术预测选择了这些数字。$2^{39}$字节是512GB，对于在RISC-V计算机上运行的应用程序来说，这应该是足够的地址空间。256足以在不久的将来容纳可能的I/O设备和DRAM芯片的物理内存空间。如果需要更多，RISC-V设计者已经定义了具有48位虚拟地址的Sv48。

​	如图 3.2 所示，RISC-V CPU 通过三个步骤将虚拟地址转换为物理地址。 页表以三级树的形式存储在物理内存中。 树的根是一个 4096 字节的页表页，包含 512 个 PTE，其中包含树的下一级页表页的物理地址。 这些页面中的每一页都包含树中最后一层的 512 个 PTE。分页硬件使用 27 位中的高 9 位选择根页表页中的 PTE，中间 9 位选择树的下一级页表页中的 PTE，低 9 位 位来选择最终的 PTE。 （在 Sv48 RISC-V 中，页表有四层，虚拟地址索引的第 39 位到第 47 位进入顶层。）

<img src="G:\typora_image_store\image-20221223151950714.png" alt="image-20221223151950714" style="zoom:80%;" />

如果转换地址所需的三个 PTE 中的任何一个不存在，分页硬件将引发页面错误异常，将其留给内核来处理异常。

​	与图 3.1 的单层设计相比，图 3.2 的三层结构允许采用内存高效的方式来记录 PTE。 在大范围虚拟地址没有映射的常见情况下，三级结构可以省略整个页目录。 例如，如果应用程序只使用从地址 0 开始的几个页面，那么顶级页面目录的条目 1 到 511 是无效的，内核不必为 511 中间页面目录分配页面。 此外，内核也不必为那些 511 中间页目录为底层页目录分配页面。 因此，在本例中，三级设计为中间页目录节省了 511 页，为底层页目录节省了 511 × 512 页。

​	尽管CPU在硬件中遍历三级结构作为执行加载或存储指令的一部分，但三级的潜在缺点是CPU必须从内存中加载三个PTE以执行加载/存储中的虚拟地址转换一个物理地址的指令。为了避免从物理内存加载PTE的成本，RISC-V CPU的缓存页表条目缓存在转换后备缓冲区（TLB）中。

​	每个 PTE 都包含标志位，告诉分页硬件如何允许使用关联的虚拟地址。 PTE_V 指示 PTE 是否存在：如果未设置，则对页面的引用会导致异常（即不允许）。 PTE_R 控制是否允许指令读取页面。 PTE_W 控制是否允许指令写入页面。 PTE_X 控制 CPU 是否可以将页面内容解释为指令并执行它们。 PTE_U 控制是否允许用户态指令访问页面； 如果未设置 PTE_U，则 PTE 只能在管理员模式下使用。 图 3.2 展示了它是如何工作的。 标志和所有其他页面硬件相关结构在 (kernel/riscv.h) 中定义

​	需要告诉硬件使用页表，内核必须将页表的物理地址写入satp寄存器。每个CPU都有自己的stap。CPU将使用自己的satp指向的页表来翻译后续指令生成的所有地址。每个CPU都有自己的satp，这样不同的CPU可以运行不同的进程，每个进程都有自己的页表描述的私有地址空间。

​	通常，内核将所有物理内存映射到其页表中，以便它可以使用加载/存储指令读取和写入物理内存中的任何位置。 由于页目录在物理内存中，内核可以通过使用标准存储指令写入 PTE 的虚拟地址来在页目录中编程 PTE 的内容。

​	关于术语的一些注释。 物理内存是指 DRAM 中的存储单元。 一个字节的物理内存有一个地址，称为物理地址。 指令只使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件以读取或写入存储。 与物理内存和虚拟地址不同，虚拟内存不是物理对象，而是指内核提供的用于管理物理内存和虚拟地址的抽象和机制的集合。

<img src="G:\typora_image_store\image-20221223160602683.png" alt="image-20221223160602683" style="zoom:80%;" />

3.2 kernel address space

​	xv6 为每个进程维护一个页表，描述每个进程的用户地址空间，以及一个描述内核地址空间的页表。 内核配置其地址空间布局，使其能够访问可预测虚拟地址处的物理内存和各种硬件资源。 图 3.3 显示了此布局如何将内核虚拟地址映射到物理地址。 文件 (kernel/memlayout.h) 声明了 xv6 内核内存布局的常量。

QEMU模拟一台包含RAM的计算机，从物理地址0x80000000开始并持续到至少0x86400000，xv6称之为PHYSTOP。QEMU 模拟还包括 I/O 设备，例如磁盘接口。 QEMU 将设备接口暴露给软件作为内存映射控制寄存器，位于 0x80000000 以下物理地址空间。 内核可以通过读/写这些特殊的物理地址来与设备进行交互； 这样的读写与设备硬件而不是 RAM 通信。 

内核使用“直接映射”获取RAM和内存映射设备寄存器，将资源映射到与物理地址相同的虚拟地址。例如，内核本身在虚拟地址空间和物理内存中都位于KERNBASE=0x80000000。直接映射简化了读取/写入物理内存的内核代码。例如fork为子进程分配用户内存时，allocator返回该内存的物理地址； fork 在将父进程的用户内存复制到子进程时，直接使用该地址作为虚拟地址。

​	有几个内核虚拟地址不是直接映射的：

* trampoline: 它被映射到虚拟地址空间的顶部； 用户页表具有相同的映射。 第 4 章讨论了 trampoline 页面的作用，但我们在这里看到了一个有趣的页表用例； 物理页面（保存trampoline代码）在内核的虚拟地址空间中映射两次：一次在虚拟地址空间的顶部，一次直接映射。
* 内核堆栈页面。 每个进程都有自己的内核栈，它被映射到高位，这样 xv6 可以在它下面留下一个未映射的保护页。 guard page的PTE是无效的（即没有设置PTE_V），所以如果内核溢出了内核栈，很可能会引发异常，内核会panic。 如果没有保护页，溢出的堆栈会覆盖其他内核内存，从而导致不正确的操作。 恐慌崩溃是可取的。
* trampoline和trapframe由操作系统分配，用户进程无权访问

​	虽然内核通过高端内存映射使用其堆栈，但内核也可以通过直接映射地址访问它们。 另一种设计可能只有直接映射，并在直接映射地址处使用堆栈。 然而，在这种安排中，提供保护页将涉及取消映射虚拟地址，否则这些虚拟地址将引用物理内存，这将很难使用。

​	内核使用 PTE_R 和 PTE_X 权限映射 trampoline 和内核文本的页面。 内核从这些页面读取并执行指令。 内核用PTE_R 和PTE_W 权限映射其他页面，以便它可以读写这些页面中的内存。 防护页的映射无效。

3.3 creating an address space

​	大多数用于操作地址空间和页表的 xv6 代码都驻留在 vm.c (kernel/vm.c:1) 中。 主要数据结构体是 `pagetable_t`，它实际上是一个指向 RISC-V 根页表页的指针； pagetable_t 可以是内核页表，也可以是每个进程页表之一。 核心功能是 `walk` 和 `mappages`，`walk`给定一个虚拟地址和一个页表返回一个PTE，后者给定一个页表、一个虚拟地址和物理地址，创建一个PTE以实现相应的映射。 以kvm开头的函数操作内核页表； 以 uvm 开头的函数操作用户页表； 其他功能用于两者。 copyout 和 copyin 从作为系统调用参数提供的用户虚拟地址复制数据； 它们在 vm.c 中，因为它们需要显式转换这些地址才能找到相应的物理内存。

​	在引导序列的早期，main 调用 `kvminit` (kernel/vm.c:54) 以使用 kvmmake (kernel/vm.c:20) 创建内核的页表。 这个调用发生在 xv6 在 RISC-V 上启用分页之前，所以地址直接指向物理内存。 kvmmake 首先分配一个物理内存页来保存根页表页。 然后它调用 kvmmap 来安装内核需要的翻译。 翻译包括内核的指令和数据、直到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。 proc_mapstacks (kernel/proc.c:33) 为每个进程分配一个内核堆栈。 它调用 kvmmap 将每个堆栈映射到 KSTACK 生成的虚拟地址，这为无效的堆栈保护页面留出了空间。

​	kvmmap (kernel/vm.c:127) 调用 mappages (kernel/vm.c:138)，它将映射安装到页表中，用于将一系列虚拟地址映射到相应的物理地址范围。 它以页面间隔为范围内的每个虚拟地址单独执行此操作。 对于每个要映射的虚拟地址，mappages 调用 walk 来查找该地址的 PTE 地址。 然后它初始化 PTE 以保存相关的物理页码、所需的权限（PTE_W、PTE_X 和/或 PTE_R）和 PTE_V 以将 PTE 标记为（kernel/vm.c:153）。

​	walk (kernel/vm.c:81) 模仿 RISC-V 分页硬件，因为它在 PTE 中查找虚拟地址（见图 3.2）。 walk当时将3级页表向下9位。 它使用每一级的 9 位虚拟地址来查找下一级页表或最终页面 (kernel/vm.c:87) 的 PTE。 如果 PTE 无效，则所需页面尚未分配； 如果设置了 alloc 参数，walk 会分配一个新的页表页并将其物理地址放入 PTE 中。 它返回树中最低层的 PTE 地址 (kernel/vm.c:97)。

​	上面的代码依赖于物理内存被直接映射到内核虚拟地址空间。 例如，当遍历页表的下层时，它从 PTE (kernel/vm.c:89) 中提取下一层页表的（物理）地址，然后将该地址用作虚拟地址 获取下一级的 PTE (kernel/vm.c:87)。

​	main 调用 kvminithart (kernel/vm.c:62) 安装内核页表。 它将根页表页的物理地址写入寄存器 satp。 此后，CPU 将使用内核页表转换地址。 由于内核使用恒等映射，下一条指令的当前虚拟地址将映射到正确的物理内存地址。

​	每个RISC-V CPU都将页表条目缓存在转换后备缓冲区（TLB）中，当xv6更改页表时，它必须告诉CPU使相应缓存的TLB条目失效。如果没有这个操作，那么在稍后的某个时候，TLB可能会使用旧的缓存映射，指向同时已分配给另一个进程的物理页面，结果会导致一个进程可能会在某些页面上更改其他进程的内存。RISC-V有一个刷新当前CPU的TLB的指令：sfence.vma。xv6在重新加载satp寄存器后在kvminithart中执行sfence.vma，并在返回用户空间之前切换到用户页表的trampoline中执行sfence.vma。

​	为避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符 (ASID)。 然后内核可以只刷新特定地址空间的 TLB 条目。

3.4 Physical memory allocation

内核必须在运行时为页表、用户内存、内核堆栈和管道缓冲区分配和释放物理内存。
xv6 使用内核末尾和 PHYSTOP 之间的物理内存进行运行时分配。 它一次分配和释放整个 4096 字节的页面。 它通过将链接列表穿过页面本身来跟踪哪些页面是空闲的。 分配包括从链表中删除一个页面； 释放：将页面添加到链表中。

3.5 code : Physical memory allocator

​	分配器位于kalloc.c中，分配器的数据结构使可用于分配的物理内存页的空闲列表。每个免费页面的列表元素是一个可用于分配的结构。分配器从哪里获得内存来保存该数据结构？它将每个空闲页面的运行结构存储在空闲页面本身之中因为没有其他存储。 空闲列表由自旋锁 (kernel/kalloc.c:21-24) 保护。 列表和锁被包装在一个结构中，以明确锁保护结构中的字段。

​	函数 main 调用 `kinit` 来初始化分配器 (kernel/kalloc.c:27)。 kinit 初始化空闲列表以保存内核末尾和 PHYSTOP 之间的每个页面。 xv6 应该通过解析硬件提供的配置信息来确定有多少物理内存可用。 相反，xv6 假定机器有 128 兆字节的 RAM。 kinit 调用 `freerange(end, PHYSTOP)` 通过每页调用 kfree 将内存添加到空闲列表。 PTE 只能引用在 4096 字节边界（是 4096 的倍数）上对齐的物理地址，因此 freerange 使用 PGROUNDUP 来确保它只释放对齐的物理地址。 分配器开始时没有内存； 这些对 kfree 的调用给它一些管理。

​	分配器有时将地址视为整数以便对其执行算术运算（例如，遍历自由范围内的所有页面），有时将地址用作读写内存的指针（例如，操纵存储在每个页面中的运行结构）； 这种地址的双重使用是分配器代码充满 C 类型转换的主要原因。 另一个原因是释放和分配本质上改变了内存的类型。

​	函数 kfree (kernel/kalloc.c:47) 首先将要释放的内存中的每个字节设置为值 1。这将导致在释放内存后使用内存的代码（使用“悬挂引用”）读取垃圾而不是 旧的有效内容； 希望这会导致此类代码更快地崩溃。 然后 kfree 将页面添加到空闲列表：它将 pa 转换为指向 struct run 的指针，在 r->next 中记录空闲列表的旧开始，并将空闲列表设置为等于 r。 kalloc 删除并返回空闲列表中的第一个元素。

<img src="G:\typora_image_store\image-20221223174337883.png" alt="image-20221223174337883" style="zoom:80%;" />

3.6 Process address space

​	每个进程都有一个单独的页表，xv6 在进程之间切换时，也会改变页表。 如图 2.3 所示，一个进程的用户内存从虚拟地址 0 开始，并且可以增加到 MAXVA (kernel/riscv.h:360)，原则上允许一个进程处理 256 GB 的内存。

​	当进程向 xv6 请求更多用户内存时，xv6 首先使用 kalloc 分配物理页面。 然后它将 PTE 添加到指向新物理页面的进程页表中。 xv6 在这些 PTE 中设置 PTE_W、PTE_X、PTE_R、PTE_U 和 PTE_V 标志。 大多数进程不使用整个用户地址空间； xv6 在未使用的 PTE 中清除 PTE_V标注位。

​	我们在这里看到了一些使用页表的很好的例子。 首先，不同进程的页表将用户地址翻译成不同的物理内存页，从而使每个进程拥有私有的用户内存。 其次，每个进程都将其内存视为具有从零开始的连续虚拟地址，而进程的物理内存可以是不连续的。 第三，内核在用户地址空间的顶部映射一个带有蹦床代码的页面，因此物理内存的单个页面出现在所有地址空间中。

​	图 3.4 更详细地显示了 xv6 中执行进程的用户内存布局。 堆栈是单页的，显示的是 exec 创建的初始内容。 包含命令行参数的字符串以及指向它们的指针数组位于堆栈的最顶部。 紧接着是允许程序从 main 开始的值，就好像函数 main(argc, argv) 刚刚被调用一样。

​	为了检测用户堆栈溢出分配的堆栈内存，xv6 通过清除 PTE_U 标志在堆栈正下方放置一个不可访问的保护页。 如果用户堆栈溢出并且进程试图使用堆栈下方的地址，则硬件将生成页面错误异常，因为在用户模式下运行的程序无法访问保护页面。 当用户堆栈溢出时，真实世界的操作系统可能会自动为用户堆栈分配更多内存。

3.7 code: sbrk

​	`sbrk` 是进程收缩或增加内存的系统调用。 系统调用由函数 growproc (kernel/proc.c:253) 实现。 growproc 调用 uvmalloc 或 uvmdealloc，这取决于 n 是正数还是负数。 uvmalloc (kernel/vm.c:221) 用kalloc分配物理内存，用mappages给用户页表添加PTE。 uvmdealloc 调用 uvmunmap(kernel/vm.c:166)，它使用 walk 查找 PTE 并使用 kfree 释放它们引用的物理内存。

​	xv6 使用进程的页表不仅告诉硬件如何映射用户虚拟地址，而且还作为唯一记录分配给该进程的物理内存页。 这就是为什么释放用户内存（在 uvmunmap 中）需要检查用户页表的原因。

3.8 code : exec

exec 为以ELF格式定义的文件系统中的可执行文件创建用户空间。 `exec`先检查头文件中是否有ELF_MAGIC来判断这个文件是否是一个ELF格式定义的二进制文件，用`proc_pagetable`来为当前进程创建一个还没有映射的页表，然后用`uvmalloc`来为每个ELF segment分配物理空间并在页表中建立映射，然后用`loadseg`来把ELF segment加载到物理空间当中。注意`uvmalloc`分配的物理内存空间可以比文件本身要大。

接下来`exec`分配user stack，它仅仅分配一页给stack，通过`copyout`将传入参数的string放在stack的顶端，在ustack的下方分配一个guard page

如果`exec`检测到错误，将跳转到`bad`标签，释放新创建的`pagetable`并返回-1。`exec`必须确定新的执行能够成功才会释放进程旧的页表(`proc_freepagetable(oldpagetable, oldsz)`)，否则如果system call不成功，就无法向旧的页表返回-1。

​	exec使用proc_pagetable(kernel/exec.c)分配一个没有用户映射的新页面，使用uvmalloc为每个ELF段分配内存，并加载每个段使用loadseg进入内存。loadseg使用walladdr找到分配内存的物理地址，在该地址写入ELF段的每个页面。并使用readi从文件中读取。

/init 的程序节标题是用 exec 创建的第一个用户程序，如下所示：

```assembly
# objdump -p _init
user/_init: file format elf64-littleriscv

Program Header:
	LOAD off 0x00000000000000b0 vaddr 0x0000000000000000
		paddr 0x0000000000000000 align 2**3
		filesz 0x0000000000000840 memsz 0x0000000000000858 flags rwx
STACK off 0x0000000000000000 vaddr 0x0000000000000000
paddr 0x0000000000000000 align 2**4
filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw
```

​	程序节头的 filesz 可能小于 memsz，表明它们之间的间隙应该用零填充（对于 C 全局变量）而不是从文件中读取。对于 /init，filesz 是 2112 字节，memsz 是 2136 字节，因此 uvmalloc 分配了足够的物理内存来容纳 2136 字节，但从文件 /init 中只读取了 2112 字节。

​	现在exec分配并初始化用户堆栈。它只分配一个堆栈页。exec一次将一个参数字符复制到栈顶，将指向它们的指针记录在ustack中。它在传递给main的argv列表的末尾放置一个空指针。ustack中的前三个条目是假的返回程序计数器、argc、和argv指针。

​	exec将一个不可访问的页面放在堆栈页面的正下方，这样试图使用多个页面的程序就会出错。这个无法访问的页面还允许exec处理参数； 在这种情况下，exec 用于将参数复制到堆栈的 copyout (kernel/vm.c:347) 函数将注意到目标页面不可访问，并将返回 -1。

​	在准备新内存映像期间，如果 exec 检测到错误，如无效程序段，它会跳转到标签 bad，释放新映像，并返回 -1。 Exec 必须等待释放旧映像，直到确定系统调用会成功：如果旧映像消失，系统调用不能返回 -1 给它。 exec 中唯一的错误情况发生在创建映像期间。 映像完成后，exec 可以提交到新页面(kernel/exec.c:113) 并释放旧页表 (kernel/exec.c:117)。

​	exec 将 ELF 文件中的字节加载到内存中由 ELF 文件指定的地址。用户或进程可以将他们想要的任何地址放入 ELF 文件中。 因此 exec 是有风险的，因为 ELF 文件中的地址可能无意或有意地引用内核。粗心的内核导致的后果可能从崩溃到恶意破坏内核的隔离机制（即安全漏洞）。Xv6 执行大量检查以避免这些风险。 例如 if(ph.vaddr + ph.memsz < ph.vaddr) 检查总和是否溢出 64 位整数。危险在于用户可以构造一个 ELF 二进制文件，其中 ph.vaddr 指向用户选择的地址，ph.memsz 足够大以至于总和溢出到 0x1000，这看起来像是一个有效值。在旧版本的 xv6 中，用户地址空间也包含内核（但在用户模式下不可读/写），用户可以选择与内核内存相对应的地址，从而将数据从 ELF 二进制文件复制到内核中 。在 xv6 的 RISC-V 版本中，这不会发生，因为内核有自己独立的页表； loadseg 加载到进程的页表中，而不是内核的页表中。

​	内核开发人员很容易忽略关键检查，而现实世界的内核长期以来一直缺少检查，用户程序可以利用这些检查来获取内核特权。 xv6 很可能没有完成验证提供给内核的用户级数据的完整工作，恶意用户程序可能会利用它来绕过 xv6 的隔离。

3.9 real world

​	与大多数操作系统一样，xv6使用分页硬件进行内存保护和映射。大多数操作系统通过结合分页和页面错误异常，比 xv6 更复杂地使用分页。

​	xv6 通过内核使用虚拟地址和物理地址之间的直接映射进行了简化，并假设在地址 0x8000000 处存在物理 RAM，内核希望将其加载。 这适用于 QEMU，但在真正的硬件上它被证明是一个坏主意； 真实硬件将 RAM 和设备放置在不可预测的物理地址，因此（例如）在 0x8000000 处可能没有 RAM，而 xv6 期望能够在此处存储内核。 更严肃的内核设计利用页表将任意硬件物理内存布局转换为可预测的内核虚拟地址布局。RISC-V 支持物理地址级别的保护，但 xv6 不使用该功能。 在具有大量内存的机器上，使用 RISC-V 对“超级页面”的支持可能是有意义的。 当物理内存较小时，小页面是有意义的，以允许以细粒度分配和页面出到磁盘。 例如，如果一个程序只使用 8 KB 的内存，那么给它一个完整的 4 MB 物理内存超级页面是一种浪费。 较大的页面在具有大量 RAM 的机器上有意义，并且可以减少页表操作的开销。xv6 内核缺少可以为小对象提供内存的类似 malloc 的分配器，这阻止了内核使用需要动态分配的复杂数据结构。

​	内存分配是一个常年的热门话题，基本问题是有效利用有限的内存和为未知的未来请求做准备[8]。 如今，人们更关心速度而不是空间效率。 此外，更精细的内核可能会分配许多不同大小的小块，而不是（如在 xv6 中）仅分配 4096 字节的块； 一个真正的内核分配器需要处理小分配和大分配。

3.10 exercises

1. 解析 RISC-V 的设备树以找到计算机拥有的物理内存量。
2. 编写一个用户程序，通过调用 sbrk(1) 将其地址空间增加一个字节。 运行程序并在调用 sbrk 之前和调用 sbrk 之后检查程序的页表。 内核分配了多少空间？ 新记忆的PTE包含什么？
3. 修改 xv6 以使用内核的超级页面。
4. 修改 xv6，以便当用户程序取消引用空指针时，它将收到异常。 也就是说，修改 xv6，使虚拟地址 0 不映射给用户程序。
5. exec 的 Unix 实现传统上包括对 shell 脚本的特殊处理。 如果要执行的文件以文本#! 开头，那么第一行将被视为要运行以解释该文件的程序。 例如，如果调用 exec 运行 myprog arg1 并且 myprog 的第一行是#!/interp，那么 exec 运行 /interp 命令行 /interp myprog arg1。 在 xv6 中实现对这个约定的支持。
6. 为内核实现地址空间随机化。

四、 traps and system calls

​	有三种事件会导致 CPU 搁置指令的普通执行，并强制将控制权转移到处理该事件的特殊代码。 一种情况是系统调用syscall，当用户程序执行 ecall 指令要求内核为它做某事时。 另一种情况是异常exception：指令（用户或内核）做了一些非法的事情，例如除以零或使用无效的虚拟地址。 第三种情况是设备中断，当设备发出需要注意的信号时，例如当磁盘硬件完成读取或写入请求时。

​	本书使用陷阱作为这些情况的通用术语。 通常，陷阱发生时，正在执行的任何代码稍后都需要恢复，并且不需要知道发生了什么特殊的事情。 也就是说，我们经常希望陷阱是透明的； 这对于设备中断尤其重要，因为中断代码通常不希望出现这种情况。 通常的顺序是陷阱强制将控制权转移到内核中； 内核保存寄存器和其他状态，以便可以恢复执行； 内核执行适当的处理程序代码（例如，系统调用实现或设备驱动程序）； 内核恢复保存的状态并从陷阱中返回； 并且原始代码从它停止的地方恢复。

​	xv6 处理内核中的所有陷阱； 陷阱不会传递给用户代码。 在内核中处理陷阱对于系统调用来说是很自然的。 这对于中断是有意义的，因为隔离要求只允许内核使用设备，并且因为内核是一种在多个进程之间共享设备的便利机制。 它对于异常也有意义，因为 xv6 通过杀死有问题的程序来响应来自用户空间的所有异常。

xv6 陷阱处理分四个阶段进行：RISC-V CPU采取的硬件操作，一些为内核 C 代码准备方式的汇编指令，决定如何处理陷阱的 C 函数，以及系统调用或设备驱动程序服务程序。虽然三种陷阱类型之间的共性表明内核可以使用单一代码路径处理所有陷阱，但事实证明为三种不同的情况使用单独的代码会很方便：即来自用户空间的陷阱、来自内核空间的陷阱和定时器中断会有不同的 handler。 处理陷阱的内核代码（汇编程序或 C）通常称为处理程序； 第一个处理程序指令通常用汇编程序（而不是 C）编写，有时称为vector。

4.1 RISC-V trap machinery

每个 RISC-V CPU 都有一组控制寄存器，内核写入这些寄存器以告诉 CPU 如何处理陷阱，内核可以读取这些寄存器以找出已发生的陷阱。 RISC-V 文档 包含完整的故事。 riscv.h (kernel/riscv.h:1) 包含 xv6 使用的定义。 以下是最重要的寄存器的概述：

* stvec：内核在这里写入它的陷阱处理程序，RISC-V跳转到stvec中的地址来处理陷阱。
* spec: 当陷阱发生时，RISC-V 将程序计数器保存在这里（因为 pc 然后被 stvec 中的值覆盖）。 sret（从陷阱返回）指令将 sepc 复制到 pc。 内核可以编写 sepc 来控制 sret 的去向。
* scause: RISC-V 在这里放了一个代码来描述陷阱的原因。
* sscractch: 内核在此处放置一个值，在陷阱处理程序的最开始时派上用场。
* sstatus : sstatus 中的 SIE 位控制是否启用设备中断。 如果内核清除 SIE，RISC-V 将推迟设备中断，直到内核设置 SIE。 SPP 位指示陷阱是来自用户模式还是管理员模式，并控制 sret 返回的模式。

上述寄存器与管理员模式下处理的陷阱有关，在用户模式下不能读写。 对于在机器模式下处理的陷阱，有一组类似的控制寄存器； xv6 仅将它们用于定时器中断的特殊情况。

多核芯片上的每个 CPU 都有自己的一组寄存器，并且在任何给定时间可能有多个 CPU 正在处理陷阱。

当发生除了计时器中断以外的其他类型的trap时，RISC-V 硬件对所有陷阱类型（定时器中断除外）执行以下操作：

1. 如果trap是一个设备中断，则sstatus的SIE位会被清除，不会做以下任何事情
2. 通过清除sstatus中的SIE位来失能中断
3. 拷贝pc到sepc
4. 在sstatus中的SPP位保存当前模式（user/supervisor）
5. 设置scause来反馈陷阱产生的原因
6. 设置模式为supervisor
7. 拷贝stvec到pc
8. 从新的pc开始执行

请注意，CPU 不会切换到内核页表，不会切换到内核中的堆栈，也不会保存 pc 以外的任何寄存器。 内核软件必须执行这些任务。
CPU 在陷阱期间做最少工作的原因之一是为软件提供灵活性； 例如，某些操作系统在某些情况下会省略页表切换以提高陷阱性能。

值得考虑是否可以省略上面列出的任何步骤，也许是为了寻找更快的陷阱。 尽管在某些情况下可以使用更简单的顺序，但通常省略许多步骤会很危险。 例如，假设 CPU 没有切换程序计数器。 然后来自用户空间的陷阱可以切换到管理员模式，同时仍在运行用户指令。 这些用户指令可能会破坏用户/内核隔离，例如通过修改 satp 寄存器以指向允许访问所有物理内存的页表。因此，CPU 切换到内核指定的指令地址很重要，即 stvec。

4.2 Traps from user space

xv6 处理陷阱的方式不同，这取决于它是在内核中执行还是在用户代码中执行。这是用户代码陷阱的故事； 4.5 节描述了来自内核代码的陷阱。

如果用户程序进行系统调用（ecall 指令）、执行非法操作或设备中断，则在用户空间执行时可能会发生陷阱。 来自用户空间的trap的高层路径是uservec(kernel/trappoline.S:16)，然后是usertrap(kernel/trap.c:37)； 返回时，usertrapret (kernel/trap.c:90) 然后是 userret (kernel/trampoline.S:88)通过sret跳回到user space。

xv6 陷阱处理设计的一个主要限制是 RISC-V 硬件在强制陷阱时不会切换页表。 这意味着 stvec 中的陷阱处理程序地址必须在用户页表中具有有效映射，因为当陷阱处理代码开始执行时，这是有效的页表。 此外，xv6 的陷阱处理代码需要切换到内核页表； 为了能够在该切换之后继续执行，内核页表还必须具有 stvec 指向的处理程序的映射。

xv6 使用`trampoline`页面来满足这些要求。 trampoline 页面包含 uservec，stvec 指向的 xv6 陷阱处理代码。 trampoline页面映射在每个进程的地址 TRAMPOLINE 处的页表，它位于虚拟地址空间的末尾，因此它将位于程序自己使用的内存之上。 trampoline页面也被映射到地址内核页表中的 TRAMPOLINE。 参见图 2.3 和图 3.3。 因为 trampoline 页面被映射到用户页表中，带有 PTE_U 标志，陷阱可以在supervisor模式下开始执行。 因为trampoline page映射到内核地址空间中的同一地址，trap handler在切换到内核页表后可以继续执行。

uservec 陷阱处理程序的代码位于 trampoline.S 。当uservec启动时，所有32个寄存器包含的值都被中断的用户代码所拥有。这 32 个值需要保存在内存中的某个地方，以便当陷阱返回到用户空间时可以恢复它们。 存储到内存需要使用寄存器来保存地址，但此时没有可用的通用寄存器！ 幸运的是，RISC-V 以 sscratch 寄存器的形式提供了帮助。 uservec 开头的 csrrw 指令交换 a0 和 sscratch 的内容。 现在用户代码的a0保存在sscratch中； uservec 有一个寄存器 (a0) 可以玩； a0 包含内核先前放置在 sscratch 中的值。

uservec 的下一个任务是保存 32 个用户寄存器。在进入用户空间之前，内核将 sscratch 设置为指向每个进程的 rapframe 结构，该结构（除其他外）有空间保存 32 个用户寄存器 (kernel/proc.h:44)。 因为satp仍然引用用户页表，所以uservec需要trapframe映射到用户地址空间。 在创建每个进程时，xv6 为进程的 trapframe 分配一个页面，并安排它始终映射到用户虚拟地址 TRAPFRAME，它就在 TRAMPOLINE 下面。 进程的 p->trapframe 也指向 trapframe，虽然是在它的物理地址，因此内核可以通过内核页表使用它。因此在交换 a0 和 sscratch 之后，a0 持有指向当前进程的陷阱帧的指针。 uservec 现在将所有用户寄存器保存在那里，包括用户的 a0，从 sscratch 读取。

trapframe中包含了当前进程的内核栈地址、当前CPU的hartid、usertrap函数的地址、内核页表的地址。 uservec 检索这些值，将 satp 切换到内核页表，并调用 usertrap。

usertrap 的工作是确定陷阱的原因，处理它，然后返回 (kernel/-trap.c:37)。 它首先更改 stvec，以便内核中的陷阱将由 kernelvec 而不是 uservec 处理。 它保存了 sepc 寄存器（保存的用户程序计数器），因为
usertrap 可能会调用 yield 切换到另一个进程的内核线程，并且该进程可能会返回到用户空间，在此过程中它会修改 sepc。 如果trap是系统调用，usertrap调用syscall来处理； 如果设备中断，devintr； 否则就是异常，内核会终止错误进程。 系统调用路径将保存的用户程序计数器加四，因为在系统调用的情况下，RISC-V 使程序指针指向 ecall 指令，但用户代码需要在后续指令处恢复执行。 在退出时，usertrap 检查进程是否已被杀死或是否应该让出 CPU（如果此陷阱是定时器中断）。

返回用户空间的第一步是调用 usertrapret (kernel/trap.c:90)。 此函数设置 RISC-V 控制寄存器，为将来来自用户空间的陷阱做准备。 这涉及更改 stvec 以引用 uservec，准备 uservec 所依赖的 trapframe 字段，以及将 sepc 设置为先前保存的用户程序计数器。 最后，usertrapret 在映射到用户和内核页表的 trampoline 页上调用 userret； 原因是userret中的汇编代码会切换页表。

usertrapret 对 userret 的调用传递了 a0 中的 TRAPFRAME 和 a1 中指向进程用户页表的指针（kernel/trampoline.S:88）。 userret 将 satp 切换到进程的用户页表。 回想一下，用户页表映射了 trampoline 页和 TRAPFRAME，但没有映射到内核。 trampoline 页映射到用户页表和内核页表中的相同虚拟地址这一事实允许 uservec 在更改 satp 后继续执行。userret 将 trapframe 的已保存用户 a0 复制到 sscratch，为以后与 TRAPFRAME 的交换做准备。 从这一点开始，userret 唯一可以使用的数据就是寄存器内容和trapframe 的内容。 接下来 userret 从 trapframe 中恢复保存的用户寄存器，最后交换 a0 和 sscratch 以恢复用户 a0 并为下一个陷阱保存 TRAPFRAME，并执行 sret 返回用户空间。

4.3 code: calling system calls

第 2 章以 initcode.S 调用 exec 系统调用 (user/initcode.S:11) 结束。 让我们看看用户调用是如何进入内核中 exec 系统调用的实现的。

initcode.S 将 exec 的参数放在寄存器 a0 和 a1 中，并将系统调用号放在 a7 中。 系统调用号与 syscalls 数组中的条目相匹配，这是一个函数指针表 (kernel/syscall.c:108)。 ecall 指令陷入内核并导致 uservec、usertrap 和 syscall 执行，如我们上面所见。

syscall (kernel/syscall.c:133) 从 trapframe 中保存的 a7 中检索系统调用号，并使用它来索引系统调用。 对于第一次系统调用，a7包含SYS_exec(kernel/syscall.h:8)，导致调用系统调用实现函数sys_exec。

当sys_exec返回时，syscall将其返回值记录在p>trapframe->a0中。 这将导致对 exec() 的原始用户空间调用返回该值，因为 RISC-V 上的 C 调用约定将返回值放在 a0 中。 系统调用通常返回负数表示错误，返回零或正数表示成功。 如果系统调用号无效，则 syscall 打印错误并返回 -1。

4.4 code: system call arguments

内核中的系统调用实现需要找到用户代码传递的参数。 因为用户代码调用系统调用包装函数，所以参数最初位于 RISC-V C 调用约定放置它们的位置：在寄存器中。 内核陷阱代码将用户寄存器保存到当前进程的trapframe中，内核代码可以在其中找到它们。 内核函数 argint、argaddr 和 argfd 从陷阱帧中检索第 n 个系统调用参数作为整数、指针或文件描述符。 它们都调用 argraw 来检索适当的已保存用户寄存器 (kernel/syscall.c:35)。

一些系统调用将指针作为参数传递，内核必须使用这些指针来读取或写入用户内存。 例如，exec 系统调用将指向用户空间中字符串参数的指针数组传递给内核。 这些指标带来了两个挑战。 首先，用户程序可能存在错误或恶意，可能会向内核传递一个无效指针或旨在诱使内核访问内核内存而不是用户内存的指针。 其次，xv6 内核页表映射与用户页表映射不同，因此内核不能使用普通指令从用户提供的地址加载或存储。

内核实现了安全地将数据传输到用户提供的地址和从用户提供的地址传输数据的功能。 fetchstr 是一个示例 (kernel/syscall.c:25)。 exec 等文件系统调用使用 fetchstr 从用户空间检索字符串文件名参数。 fetchstr 调用 copyinstr 来完成任务工作。

copyinstr (kernel/vm.c:398) 从用户页表 pagetable 中的虚拟地址 srcva 复制最大字节数到 dst。 由于 pagetable 不是当前页表，copyinstr 使用 walkaddr（调用 walk）在 pagetable 中查找 srcva，产生物理地址 pa0。 内核将每个物理RAM地址映射到对应的内核虚拟地址，因此copyinstr可以直接将字符串字节从pa0复制到dst。 walkaddr (kernel/vm.c:104) 检查用户提供的虚拟地址是进程用户地址空间的一部分，所以程序不能欺骗内核读取其他内存。 类似的函数 copyout 将数据从内核复制到用户提供的地址。

4.5 traps from kernel space

xv6 根据执行的是用户代码还是内核代码，对 CPU 陷阱寄存器的配置略有不同。 当内核在 CPU 上执行时，内核将 stvec 指向程序集kernelvec 中的代码 (kernel/kernelvec.S:10)。 由于 xv6 已经在内核中，kernelvec 可以依赖于将 satp 设置为内核页表，以及指向有效内核堆栈的堆栈指针。 kernelvec 将所有 32 个寄存器压入堆栈，稍后它将从堆栈中恢复它们，以便中断的内核代码可以不受干扰地恢复。

kernelvec 将寄存器保存在中断的内核线程的堆栈中，这是有道理的，因为寄存器值属于该线程。 如果陷阱导致切换到不同的线程，这一点尤其重要——在这种情况下，陷阱实际上会从新线程的堆栈中返回，将被中断线程保存的寄存器安全地留在其堆栈中。

kernelvec 在保存寄存器后跳转到 kerneltrap (kernel/trap.c:134)。 kerneltrap 为两种类型的陷阱准备：设备中断和异常。 它调用 devintr (kernel/-trap.c:177) 来检查和处理前者。 如果陷阱不是设备中断，它一定是一个异常，如果它发生在 xv6 内核中，那总是一个致命错误； 内核调用 panic 并停止执行。

如果 kerneltrap 由于计时器中断而被调用，并且进程的内核线程正在运行（而不是调度程序线程），则 kerneltrap 调用 yield 来为其他线程提供运行的机会。在某个时候，其中一个线程会让步，让我们的线程和它的内核陷阱再次恢复。 第 7 章解释了 yield 中发生的事情。

当 kerneltrap 的工作完成后，它需要返回到被陷阱中断的任何代码。 因为 yield 可能会干扰 sepc 和 sstatus 中的先前模式，所以 kerneltrap 在启动时会保存它们。 它现在恢复那些控制寄存器并返回到
kernelvec（内核/kernelvec.S:48）。 kernelvec 从堆栈中弹出保存的寄存器并执行 sret，它将 sepc 复制到 pc 并恢复中断的内核代码。

如果 kerneltrap 由于定时器中断而调用 yield，那么值得思考陷阱返回是如何发生的。

当 CPU 从用户空间进入内核时，xv6 将 CPU 的 stvec 设置为 kernelvec； 您可以在 usertrap (kernel/trap.c:29) 中看到这一点。 内核开始执行时有一个时间窗口，但 stvec 仍设置为 uservec，在该窗口期间没有设备中断发生是至关重要的。 幸运的是，RISC-V 在开始捕获陷阱时总是禁用中断，而 xv6 在设置 stvec 之前不会再次启用它们。

4.6 page-fault exceptions

许多内核使用页面错误来实现写时复制 (Copy-on-Write) fork。要解释写时复制 fork，请考虑第 3 章中描述的 xv6 的 fork。fork 导致子进程的初始内存内容与 fork 时父进程的内存内容相同。 xv6 使用 uvmcopy (kernel/vm.c:301) 实现 fork，它为子进程分配物理内存并将父进程的内存复制到其中。 如果子进程和父进程可以共享父进程的物理内存，效率会更高。 然而，直接实现这一点是行不通的，因为它会导致父子进程通过写入共享堆栈和堆来干扰彼此的执行。

通过适当使用页表权限和页面错误，父进程和子进程可以安全地共享物理内存。 当使用的虚拟地址在页表中没有映射，或者具有 PTE_V 标志为清除的映射，或者其许可位（PTE_R、PTE_W、PTE_X、PTE_U）禁止的映射时，CPU 会引发页面错误异常正在尝试操作。 RISC-V 区分了三种页面错误：加载页面错误load page faults（当加载指令无法转换其虚拟地址时）、存储页面错误store page faults（当存储指令无法转换其虚拟地址时）和指令页面错误instruction page faults（当一个instruction的地址无法翻译时发生）。 scause 寄存器指示页面错误的类型，而 stval 寄存器包含无法翻译的地址。在xv6中对于exception一律都会将这个进程kill掉，但是实际上可以结合page faults实现一些功能。：

1.可以实现*copy-on-write fork*。在`fork`时，一般都是将父进程的所有user memory复制到子进程中，但是`fork`之后一般会直接进行`exec`，这就会导致复制过来的user memory又被放弃掉。因此改进的思路是：子进程和父进程共享一个物理内存，但是mapping时将PTE_W置零，只有当子进程或者父进程的其中一个进程需要向这个地址写入时产生page fault，此时才会进行copy。

2.可以实现*lazy allocation*。旧的`sbrk()`申请分配内存，但是申请的这些内存进程很可能不会全部用到，因此改进方案为：当进程调用`sbrk()`时，将修改`p->sz`，但是并不实际分配内存，并且将PTE_V置0。当在试图访问这些新的地址时发生page fault再进行物理内存的分配。

3.*paging from disk*：当内存没有足够的物理空间时，可以先将数据存储在其他的存储介质（比如硬盘）上，，将该地址的PTE设置为invalid，使其成为一个evicted page。当需要读或者写这个PTE时，产生Page fault，然后在内存上分配一个物理地址，将这个硬盘上的evicted page的内容写入到该内存上，设置PTE为valid并且引用到这个内存物理地址。

COW fork 中的基本计划是让父进程和子进程共享所有物理页面，但每个人都将它们映射为只读（清除 PTE_W 标志）。 父进程和子进程可以从共享的物理内存中读取。 如果任一者写入给定页面，RISC-V CPU 将引发页面错误异常。 内核的陷阱处理程序通过分配一个新的物理内存页面并将错误地址映射到的物理页面复制到其中来做出响应。内核更改故障进程页表中的相关 PTE 以指向副本并允许写入和读取，然后在导致故障的指令处恢复故障进程。 由于 PTE 允许写入，因此重新执行的指令现在将无故障执行。 写时复制需要簿记（book-keeping）以帮助决定何时可以释放物理页面，因为每个页面都可以由不同数量的页表引用，具体取决于fork、页面错误（page faults）、执行（execs）和退出（exits）的历史记录。 这种簿记（book-keeping）允许一个重要的优化：如果进程发生存储页面错误并且物理页面仅从该进程的页表中引用，则不需要副本。

写时复制使 fork 更快，因为 fork 不需要复制内存。 一些内存必须在以后写入时复制，但通常情况下大部分内存永远不必复制。 一个常见的例子是 fork 之后是 exec：在 fork 之后可能会写入几页，但是随后子进程的 exec 释放了从父进程继承的大部分内存。
写时复制 fork 消除了复制此内存的需要。 此外，COW fork是透明的：无需对应用程序进行任何修改即可使它们受益。

页表和页错误的结合开辟了除 COW fork 之外的广泛有趣的可能性。 另一个广泛使用的特性称为惰性分配（lazy allocation），它有两个部分。 首先，当应用程序通过调用 sbrk 请求更多内存时，内核会注意到大小的增加，但不会分配物理内存，也不会为新的虚拟地址范围创建 PTE。 其次，在其中一个新地址发生页面错误时，内核会分配一页物理内存并将其映射到页表中。 与 COW fork 一样，内核可以对应用程序透明地实现惰性分配。

由于应用程序经常请求比他们需要的更多的内存，延迟分配是一个胜利：内核根本不需要为应用程序从不使用的页面做任何工作。 此外，如果应用程序要求大量增加地址空间，那么没有惰性分配的 sbrk 是昂贵的：如果应用程序要求 1 GB 的内存，内核必须分配和归零 262,144 个 4096 字节的页面。 惰性分配允许此成本随着时间的推移而分散。另一方面，惰性分配会导致页面错误的额外开销，这涉及内核/用户转换。 操作系统可以通过为每个页面错误分配一批连续的页面而不是一个页面来降低这种成本，并通过为此类页面错误专门化内核进入/退出代码。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

另一个广泛使用的利用页面错误的功能是请求分页。 在 exec 中，xv6 将应用程序的所有文本和数据急切地加载到内存中。 由于应用程序可能很大并且从磁盘读取的成本很高，因此用户可能会注意到这种启动成本：当用户从 shell 启动大型应用程序时，可能需要很长时间才能看到响应。 为了缩短响应时间，现代内核为用户地址空间创建页表，但将页面的 PTE 标记为无效。 发生页面错误时，内核从磁盘读取页面内容并将其映射到用户地址空间。 与 COW fork 和惰性分配一样，内核可以对应用程序透明地实现此功能。

在计算机上运行的程序可能需要比计算机的 RAM 更多的内存。 为了优雅地应对，操作系统可以实现分页到磁盘。 这个想法是只将一小部分用户页面存储在 RAM 中，并将其余部分存储在磁盘上的分页区域中。 内核将与存储在分页区域（因此不在 RAM 中）的内存相对应的 PTE 标记为无效。 如果应用程序试图使用已调出到磁盘的页面之一，应用程序将招致page fault，必须将page调入：kernel trap handler会分配物理RAM的page，将page从磁盘读入RAM，并修改相关的PTE指向RAM。

如果页面需要调入，但没有可用的物理 RAM，会发生什么情况？ 在这种情况下，内核必须首先通过将物理页面调出或逐出到磁盘上的分页区域来释放物理页面，并将引用该物理页面的 PTE 标记为无效。 逐出是昂贵的，因此分页在不频繁的情况下表现最佳：如果应用程序仅使用其内存页面的一个子集并且子集的并集适合 RAM。 此属性通常被称为具有良好的参考位置。 与许多虚拟内存技术一样，内核通常以对应用程序透明的方式实现磁盘分页。

无论硬件提供多少 RAM，计算机通常在很少或没有可用物理内存的情况下运行。 例如，云提供商在一台机器上多路复用许多客户，以经济高效地使用他们的硬件。 再举一个例子，用户在智能手机上运行很多应用程序的物理内存很少。 在这样的设置中，分配页面可能需要先驱逐现有页面。 因此，当空闲物理内存稀缺时，分配是昂贵的。

当可用内存不足时，惰性分配和请求分页特别有利。在 sbrk 或 exec 中急切地分配内存会导致额外的逐出成本以使内存可用。 此外，还存在浪费急切工作的风险，因为在应用程序使用该页面之前，操作系统可能已将其逐出。

结合分页和页面错误异常的其他功能包括自动扩展堆栈和内存映射文件。

4.7 real world

trampoline和陷阱框架可能看起来过于复杂。 一个驱动力是 RISCV 在强制陷阱时有意做尽可能少的事情，以允许非常快速的陷阱处理的可能性，这很重要。 因此，内核陷阱处理程序的前几条指令实际上必须在用户环境中执行：用户页表和用户寄存器内容。并且陷阱处理程序最初不知道有用的事实，例如正在运行的进程的标识或内核页表的地址。一个解决方案是可能的，因为 RISC-V 提供了受保护的地方，内核可以在进入之前隐藏信息用户空间：sscratch 寄存器和指向内核内存但由于缺少 PTE_U 而受到保护的用户页表条目。 xv6 的 trampoline 和 trapframe 利用了这些 RISC-V 特性。

如果将内核内存映射到每个进程的用户页表（具有适当的 PTE 权限标志），则可以消除对特殊trampoline页的需求。 当从用户空间陷入内核时，这也将消除对页表切换的需要。 这反过来将允许内核中的系统调用实现利用当前进程的用户内存被映射，从而允许内核代码直接取消引用用户指针。许多操作系统都使用这些想法来提高效率。 xv6 避免使用它们是为了减少由于无意中使用用户指针而导致内核出现安全漏洞的可能性，并降低确保用户和内核虚拟地址不重叠所需的一些复杂性。

生产操作系统实现写时复制fork、惰性分配、请求分页、分页到磁盘、内存映射文件等。此外，生产操作系统将尝试使用所有物理内存，用于应用程序或缓存（例如， 文件系统的缓冲区缓存，我们将在后面的第 8.2 节中介绍）。 xv6 在这方面是天真的：你希望你的操作系统使用你支付的物理内存，但 xv6 不会。 此外，如果 xv6内存不足时，它会向正在运行的应用程序返回一个错误或终止它，而不是例如驱逐另一个应用程序的页面。

4.8 exercises

1. 函数 copyin 和 copyinstr 在软件中遍历用户页表。 设置内核页表，使内核映射用户程序，copyin 和 copyinstr 可以使用 memcpy 将系统调用参数复制到内核空间，依靠硬件进行页表遍历。
2. 实现lazy memory allocation。
3. 实现COW fork。
4. 有没有办法消除每个用户地址空间中的特殊 TRAPFRAME 页面映射？ 例如，是否可以将 uservec 修改为简单地将 32 个用户寄存器压入内核堆栈，或者将它们存储在 proc 结构中？
5. 是否可以修改 xv6 以消除特殊的 TRAMPOLINE 页面映射？

五、Interrupts and device drivers

驱动程序是操作系统中管理特定设备的代码：它配置设备硬件，告诉设备执行操作，处理产生的中断，并与可能等待设备 I/O 的进程交互。 驱动程序代码可能很棘手，因为驱动程序与其管理的设备同时执行。此外，驱动程序必须了解设备的硬件接口，该接口可能很复杂且文档不足。

需要操作系统注意的设备通常可以配置为生成中断，这是一种陷阱。 内核陷阱处理代码识别设备何时引发中断并调用驱动程序的中断处理程序； 在 xv6 中，这种调度发生在 `devintr` (kernel/trap.c:177) 中。

许多设备驱动程序在两种上下文中执行代码：上半部分在进程的内核线程中运行，下半部分在中断时执行。 上半部分通过syscall调用，例如希望设备执行 I/O 的读取和写入。 这段代码可能会要求硬件开始一个操作（例如，要求磁盘读取一个块）； 然后代码等待操作完成。 最终设备完成操作并引发中断。驱动程序的中断处理程序充当下半部分，找出已完成的操作，在适当的情况下唤醒等待进程，并告诉硬件开始处理任何等待的下一个操作。

5.1 code : console input

控制台驱动程序 (kernel/console.c) 是驱动程序结构的简单说明。 控制台驱动程序通过连接到 RISC-V 的 UART 串行端口硬件接受人类键入的字符。控制台驱动程序一次累积一行输入，处理退格和控制-u 等特殊输入字符。用户进程（例如 shell）使用 read 系统调用从控制台获取输入行。 当在 QEMU 中向 xv6 键入输入时，您的击键将通过 QEMU 的模拟 UART 硬件传送到 xv6。

驱动程序与之通信的 UART 硬件是 QEMU 模拟的 16550 芯片。 在真实的计算机上，16550 将管理连接到终端或其他计算机的 RS232 串行链路。当运行 QEMU 时，它连接到你的键盘和显示器。

UART 硬件在软件看来是一组内存映射控制寄存器。 也就是说，RISC-V 硬件有一些物理地址连接到 UART 设备，因此加载和存储与设备硬件而不是 RAM 交互。 UART 的内存映射地址从 0x10000000 或 UART0 (kernel/memlayout.h:21) 开始。 有一些 UART 控制寄存器，每个都是一个字节的宽度。 它们与 UART0 的偏移量在 (kernel/uart.c:22) 中定义。 例如，LSR 寄存器包含指示输入字符是否正在等待软件读取的位。 这些字符（如果有的话）可用于读取RHR 寄存器。 每次读取一个，UART 硬件将其从等待字符的内部 FIFO 中删除，并在 FIFO 为空时清除 LSR 中的“就绪”位。 UART 发送硬件在很大程度上独立于接收硬件； 如果软件向 THR 写入一个字节，则 UART 传输该字节。

xv6 的主要调用 consoleinit (kernel/console.c:182) 来初始化 UART 硬件。 此代码将 UART 配置为在 UART 接收到每个输入字节时生成一个接收中断，并在每次 UART 完成发送一个字节的输出时生成一个传输完成中断 (kernel/uart.c:53)。

xv6 shell 通过 init.c (user/init.c:19) 打开的文件描述符从控制台读取。 对 read 系统调用的调用通过内核到达 consoleread (kernel/console.c:80)。 consoleread 等待输入到达（通过中断）并缓存在 cons.buf中 ，将输入拷贝到用户空间，然后（在整行到达后）返回到用户进程。 如果用户还没有输入整行，则读取进程将在sleep system call中等待。

当用户键入一个字符时，UART 硬件要求 RISC-V 产生一个中断，从而激活 xv6 的陷阱处理程序。 陷阱处理程序调用 devintr (kernel/trap.c:177)，它查看 RISC-V `scause`寄存器判断中断是否来自外部设备。 然后它要求一个称为 PLIC的硬件单元告诉它哪个设备发生中断 (kernel/trap.c:186)。 如果是 UART，devintr 调用 uartintr。uartintr (kernel/uart.c:180) 从 UART 硬件读取任何等待输入的字符并将它们交给 consoleintr (kernel/console.c:136)； 它不等待字符，因为 future输入将引发新的中断。 `consoleintr`将积累这些字符直到整行都已经被读取，然后将唤醒仍在`sleep`的`consoleread`。当`consoleread`被唤醒后，将这一行命令复制给user space然后返回。

* LSR寄存器：用来指示输入的字符是否准备好被用户进程读取
* RHR寄存器：用来放置可以被用户进程读取的字节，让RHR中的一个字节被读取时，UART硬件将其从内部的FIFO硬盘中删除，当FIFO中为空时，LSR寄存器被置为0。
* THR寄存器：当用户进程向THR写入一个字节时，UART将传输这个字节。

5.2 code : console output

对连接到控制台的文件描述符的写入系统调用最终到达 uartputc (kernel/uart.c:87)。 设备驱动维护一个输出缓冲区（uart_tx_buf），这样写进程就不必等待UART完成发送； 相反，uartputc 将每个字符附加到缓冲区，调用 uartstart 以启动设备传输（如果尚未传输），然后返回。 uartputc 等待的唯一情况是缓冲区已满。

每次 UART 完成发送一个字节时，它都会产生一个中断。 uartintr 调用 uartstart，它检查设备是否真正完成发送，并将下一个缓冲输出字符交给设备。 因此，如果进程向控制台写入多个字节，通常第一个字节将由 uartputc 调用 uartstart 发送，其余缓冲字节将由当传输完成中断到达时，从 uartintr 调用 uartstart。

需要注意的一般模式是通过缓冲和中断将设备活动与进程活动分离。 即使没有进程在等待读取输入，控制台驱动程序也可以处理输入； 一种随后的阅读将看到输入。 同样，进程可以发送输出而无需等待设备。 这种分离可以通过允许进程与设备 I/O 并发执行来提高性能，并且在设备速度较慢（如 UART）或需要立即关注（如回显键入的字符）时尤为重要。 这种想法有时称为 I/O 并发。

5.3 concurrency in drivers

您可能已经注意到在 consoleread 和 consoleintr 中对 acquire 的调用。 这些调用获取一个锁，以保护控制台驱动程序的数据结构免受并发访问。 这里存在三个并发危险：不同 CPU 上的两个进程可能同时调用 consoleread； 当 CPU 已经在 consoleread 中执行时，硬件可能会要求 CPU 发送一个控制台（实际上是 UART）中断； 并且当 consoleread 正在执行时，硬件可能会在不同的 CPU 上发送控制台中断。 这些危险可能会导致竞争条件或死锁。 第 6 章探讨了这些问题以及锁如何解决这些问题。

在驱动程序中需要注意并发性的另一种方式是，一个进程可能正在等待来自设备的输入，但是当另一个进程（或根本没有进程）正在运行时，输入的中断信号到达可能会到达。 因此，不允许中断处理程序考虑它们已中断的进程或代码。 例如，中断处理程序无法使用当前进程的页表安全地调用 copyout。 中断处理程序通常做相对较少的工作（例如，只需将输入数据复制到缓冲区），然后唤醒上半部分代码来完成其余工作。

5.4 timer interrupts

xv6 使用定时器中断来维护它的时钟并使其能够在计算密集型进程之间切换； usertrap 和 kerneltrap 中的 yield 调用导致了这种切换。 定时器中断来自连接到每个 RISC-V CPU 的时钟硬件。 xv6 对该时钟硬件进行编程以周期性地中断每个 CPU。

RISC-V 要求定时器中断在机器模式下进行，而不是管理员模式。 RISCV 机器模式在没有分页的情况下执行，并且有一组单独的控制寄存器，因此在机器模式下运行普通的 xv6 内核代码是不切实际的。 因此，xv6 完全独立于上面列出的陷阱机制来处理定时器中断。

在 main 之前，在 start.c 中以机器模式执行的代码设置为接收定时器中断 (kernel/start.c:62)。 部分工作是对 CLINT 硬件（核心本地中断器）进行编程，使其在一定延迟后生成中断。 另一部分是设置一个类似于trapframe的scratch area，帮助timer interrupt handler保存寄存器和CLINT寄存器的地址。最后，start 将 mtvec 设置为 timervec 并启用定时器中断。

当用户或内核代码正在执行时，定时器中断可以在任何时候发生； 内核无法在关键操作期间禁用定时器中断。 因此，定时器中断处理程序必须以一种保证不会干扰被中断的内核代码的方式来完成它的工作。 基本策略是处理程序要求 RISC-V 引发“软件中断”并立即返回。 RISC-V 通过普通的陷阱机制将软件中断传递给内核，并允许内核禁用它们。 可以在 devintr (kernel/trap.c:204) 中看到处理定时器中断产生的软件中断的代码。

机器模式定时器中断处理程序是 timervec (kernel/kernelvec.S:93)。 它在start准备的scratch区保存了几个寄存器，告诉CLINT什么时候产生下一个定时器中断，要求 RISC-V 引发软件中断，恢复寄存器，然后返回。 定时器中断处理程序中没有 C 代码。

5.5 real world

xv6 允许在内核中执行设备和定时器中断，以及在执行用户程序时。 定时器中断强制从定时器中断处理程序进行线程切换（调用 yield），即使在内核中执行也是如此。 如果内核线程有时花费大量时间计算而不返回用户空间，则在内核线程之间公平地对 CPU 进行时间切片的能力非常有用。 然而，内核代码需要注意它可能会被挂起（由于一个定时器中断）然后在不同的 CPU 上恢复是 xv6 中一些复杂性的来源（参见第 6.6 节）。 如果设备和定时器中断仅在执行用户代码时发生，内核可以变得更简单。

在典型计算机上支持所有设备的全部工作量很大，因为有很多设备，设备有很多功能，设备和驱动程序之间的协议可能很复杂并且文档很少。 在许多操作系统中，驱动程序所占的代码多于核心内核。

UART 驱动程序通过读取 UART 控制寄存器一次一个字节地检索数据； 这种模式称为编程 I/O，因为软件驱动数据移动。 编程 I/O 很简单，但速度太慢，无法在高数据速率下使用。 需要高速移动大量数据的设备通常使用直接内存访问 (DMA)。 DMA 设备硬件直接将传入数据写入 RAM，并从 RAM 读取传出数据。 现代磁盘和网络设备使用 DMA。 DMA 设备的驱动程序会在 RAM 中准备数据，然后使用对控制寄存器的单次写入来告诉设备处理准备好的数据。

当一个设备在不可预知的时间需要注意而不是太频繁时，中断是有意义的。 但是中断有很高的 CPU 开销。 因此，高速设备（例如网络和磁盘控制器）使用减少中断需求的技巧。 一个技巧是为整批传入或传出请求引发单个中断。 另一个技巧是驱动程序完全禁用中断，并定期检查设备以查看是否需要注意。 这种技术称为轮询。 如果设备非常快速地执行操作，轮询是有意义的，但如果设备大部分时间都处于空闲状态，则轮询会浪费 CPU 时间。 某些驱动程序根据当前设备负载在轮询和中断之间动态切换。

UART 驱动程序首先将传入数据复制到内核中的缓冲区，然后再复制到用户空间。 这在低数据速率下是有意义的，但这样的双重副本会显着降低快速生成或使用数据的设备的性能。 一些操作系统能够直接在用户空间缓冲区和设备硬件之间移动数据，通常使用 DMA。

如第 1 章所述，控制台对应用程序来说就像一个常规文件，应用程序使用读写系统调用读取输入和写入输出。 应用程序可能想要控制无法通过标准文件系统调用表达的设备方面（例如，在控制台驱动程序中启用/禁用行缓冲）。 Unix 操作系统支持针对此类情况的 ioctl 系统调用。

计算机的某些用途要求系统必须在限定时间内做出响应。 例如，在安全关键系统中，错过最后期限可能会导致灾难。 xv6 不适合硬实时设置。 硬实时操作系统往往是与应用程序链接的库，允许通过分析确定最坏情况下的响应时间。 xv6 也不适合软实时应用程序，偶尔错过最后期限是可以接受的，因为 xv6 的调度程序过于简单，并且它具有长时间禁用中断的内核代码路径。

5.6 exercises

1. 修改 uart.c 以完全不使用中断。 您可能还需要修改 console.c。
2. 为以太网卡添加驱动程序。

六、locking

大多数内核，包括 xv6，交错执行多个活动。 交错的来源之一是多处理器硬件：具有多个独立执行的 CPU 的计算机，例如 xv6 的 RISC-V。 这些多个 CPU 共享物理 RAM，xv6 利用共享来维护所有 CPU 读写的数据结构。 这种共享增加了一个 CPU 读取数据结构而另一个 CPU 正在更新数据结构的可能性，甚至多个 CPU 同时更新相同数据的可能性； 如果没有精心设计，这种并行访问很可能会产生不正确的结果或损坏的数据结构。 即使在单处理器上，内核也可能在多个线程之间切换 CPU，导致它们的执行交错。 最后，如果中断发生在错误的时间，则修改与某些可中断代码相同的数据的设 备中断处理程序可能会损坏数据。 并发一词是指由于多处理器并行性、线程切换或中断而导致多个指令流交错的情况。

内核充满了并发访问的数据。 例如，两个 CPU 可以同时调用 kalloc，从而同时从空闲列表的头部弹出。 内核设计者喜欢允许大量的并发，因为它可以通过并行性和响应性提高来提高性能。然而，结果是内核设计者花了很多精力说服自己尽管有这种并发性，但仍然是正确的。 有很多方法可以获得正确的代码，其中一些比其他的更容易推理。 以并发下的正确性为目标的策略，以及支持它们的抽象，被称为并发控制技术。

xv6 根据情况使用多种并发控制技术。 本章重点介绍一种广泛使用的技术：锁。 锁提供互斥，确保一次只有一个 CPU 可以持有锁。 如果程序员为每个共享数据项关联一个锁，并且代码在使用某个项时始终持有关联的锁，那么该项将一次仅由一个 CPU 使用。 在这种情况下，我们说锁保护了数据项。 虽然锁是一种易于理解的并发控制机制，但锁的缺点是它们会扼杀性能，因为它们会序列化并发操作。

<img src="G:\typora_image_store\image-20230108165150143.png" alt="image-20230108165150143" style="zoom:67%;" />

6.1 race conditions

作为我们为什么需要锁的一个例子，考虑在两个不同的 CPU 上调用 wait 的两个进程。 等待释放子进程的内存。 因此在每个 CPU 上，内核将调用 kfree 来释放子页面。 内核分配器维护一个链表：kalloc() (kernel/kalloc.c:69) 从空闲页面列表中弹出一个内存页面，kfree() 将一个页面压入空闲列表。 为了获得最佳性能，我们可能希望两个父进程的 kfree 并行执行，而不必等待另一个，但考虑到 xv6 的 kfree 实现，这是不正确的。图 6.1 更详细地说明了设置：链表位于两个 CPU 共享的内存中，这两个 CPU 使用加载和存储指令来操作链表。 （实际上，处理器有缓存，但从概念上讲，多处理器系统的行为就像有一个共享内存一样。）如果没有并发请求，您可以按如下方式实现列表推送操作：

```c
struct element {
    int data;
    struct element *next;
};
struct element *list = 0;
void push(int data)
{
    struct element *l
    l = malloc(sizeof *l);
    l -> data = data;
    l -> next = list;
    list = l;
}
```

<img src="G:\typora_image_store\image-20230108165514351.png" alt="image-20230108165514351" style="zoom:80%;" />

如果单独执行，此实现是正确的。 但是，如果多个副本同时执行，则代码不正确。 如果两个 CPU 同时执行 push，它们都可能先执行图 6.1 所示的第 15 行，然后再执行第 16 行，这会导致错误的结果，如图 6.2 所示。 然后将有两个列表元素，其 next 设置为列表的前一个值。 当 list 的两个赋值发生在第 16 行时，第二个将覆盖第一个； 第一个赋值中涉及的元素将丢失。

第 16 行丢失的更新是竞争条件的一个例子。 竞争条件是同时访问内存位置并且至少有一次访问是写入的情况。 一个竞争往往是错误的迹象，更新丢失（如果访问是写入）或读取未完全更新的数据结构。 比赛的结果取决于所涉及的两个 CPU 的确切时间和内存系统如何对它们的内存操作进行排序，这会使竞争引起的错误难以重现和调试。 例如，在调试推送时添加打印语句可能会改变执行时间，足以使竞争消失。避免竞争的通常方法是使用🔒。锁确保互斥，使同一时间只有一个CPU可以执行push的敏感行，这使得上述情况不可能发生。

```c
struct element *list = 0;
struct lock listlock;
void push(int data)
{
    struct element *l;
    l = malloc(sizeof *l);
    l -> data = data;
    acquire(&listlock);
    l -> next = list;
    list = l;
    release(&listlock);
}
```

获取和释放之间的指令序列通常称为临界区。 锁通常被称为保护列表。当我们说锁保护数据时，我们的意思是锁保护了一些适用于数据的不变量集合。 不变量是被维护的数据结构的属性跨操作。 通常，操作的正确行为取决于操作开始时不变量是否为真。 该操作可能会暂时违反不变量，但必须在完成之前重新建立它们。 例如，在链表的情况下，不变量是列表指向列表中的第一个元素，每个元素的下一个字段指向下一个元素。 push 的实现暂时违反了这个不变量：在第 17 行，l 指向下一个列表元素，但 list 还没有指向 l（在第 18 行重新建立）。 我们上面检查的竞争条件的发生是因为第二个 CPU 执行了依赖于列表不变量的代码，而它们（暂时）被违反了。 正确使用锁可以确保同一时刻只有一个 CPU 可以对临界区中的数据结构进行操作，这样当数据结构的不变量不成立时，没有 CPU 会执行数据结构操作。

您可以将锁视为序列化并发关键部分，以便它们一次运行一个，从而保留不变量（假设关键部分在隔离时是正确的）。 您还可以将由同一锁保护的关键部分视为彼此之间的原子性，这样每个关键部分只能看到来自早期关键部分的完整更改集，而永远不会看到部分完成的更新。

虽然正确使用锁可以使不正确的代码正确，但锁会限制性能。 例如，如果两个进程并发调用 kfree，锁将序列化这两个调用，我们不会从在不同 CPU 上运行它们中获益。 如果多个进程同时想要同一个锁，我们说多个进程发生冲突，或者锁发生争用。 内核设计的一个主要挑战是避免锁争用。 Xv6 做的很少，但复杂的内核专门组织数据结构和算法以避免锁争用。 在列表示例中，内核可以为每个 CPU 维护一个空闲列表，并且只有在 CPU 的列表为空并且它必须从另一个 CPU 窃取内存时才接触另一个 CPU 的空闲列表。 其他用例可能需要更复杂的设计。

锁的放置对于性能也很重要。 例如，在 push 中将 acquire 移到更早的位置是正确的：将对 acquire 的调用移到第 13 行之前是可以的。这可能会降低性能，因为对 malloc 的调用也会被序列化。 下面的“使用锁”部分提供了一些关于在何处插入获取和释放调用的指南。

6.2 code: locks

xv6有两种类型的锁，spinlock和sleep-locks，spinlock的代码位于kernel/spinlock.h的`struct spinlock`中。

```c
struct spinlock {
    uint locked;  //为0时说明这个锁可以获取
    char *name;
    struct cpu *cpu;
};
```

```c
void acpuire(struct spinlock *lk)
{
    for(;;){
        if(lk -> locked == 0){
            lk -> locked = 1;
            break;
        }
    }
}
```

不幸的是，这种实现并不能保证多处理器上的互斥。 有可能两个CPU同时到达25行，看到lk->locked为0，然后都通过执行第26行抢到了锁，此时两个不同的CPU都持有了锁，违反了互斥性。 我们需要的是一种使第 25 行和第 26 行作为原子（即不可分割）步骤执行的方法。

由于锁被广泛使用，多核处理器通常提供实现第 25 和 26 行原子版本的指令。在 RISC-V 上，这条指令是 amoswap r, a。 amoswap 交换a内存地址中的内容和r寄存器中的内容。 也就是说，它交换了寄存器的内容和内存地址。 它以原子方式执行这个序列，使用特殊硬件来防止任何其他 CPU从使用读取和写入之间的内存地址。

xv6 的 acquire (kernel/spinlock.c:22) 使用可移植的 C 库调用 `__sync_lock_test_and_set`，归结为 amoswap 指令； 返回值是旧的（交换的）内容lk->locked。 acquire 函数将交换包装在一个循环中，重试（自旋）直到它获得锁。 每次迭代将一个交换到 lk->locked 并检查先前的值； 如果之前的值为0，那么我们已经获得了锁，跳出循环，交换将设置 lk->locked到1。 如果之前的值是1，那么其他 CPU 持有锁，而我们以原子方式将1交换到 lk->locked 的事实并没有改变它的值。

```c
while(__sync_lock_test_and_set(&lk -> locked, 1) != 0)
    ;
```

获取到锁后，获取记录获取锁的CPU，方便调试。 lk->cpu 字段受锁保护，只能在持有锁时更改。

函数release(kernel/spinlock.c:47)与acquire相反：它清除lk->cpu域，然后释放锁。 从概念上讲，该版本只需要将零分配给 lk->locked。C 标准库允许编译器使用多个存储指令实现赋值，因此 C 赋值对于并发代码而言可能是非原子的。 相反，release 使用执行原子分配的 C 库函数 `__sync_lock_release`。 这个函数也归结为一条 RISC-V amoswap 指令。

由于编译器有时候为了性能优化会重新排列代码的执行顺序，对于顺序执行的代码来说，这种重新排列顺序并不会改变代码执行的结果，但是对于并发执行的代码，则可能改变结果，因此需要在`acquire`和`release`中用`__sync_synchronize()`来保证CPU和编译器不进行重新排列顺序。`__sync_synchronize()`是一个barrier，任何在这一行代码之前的代码都不能reorder到这一行代码的后面。

6.3 code: using locks

Xv6 在许多地方使用锁来避免竞争条件。 如上所述，kalloc (kernel/kalloc.c:69) 和 kfree (kernel/kalloc.c:47) 是一个很好的例子。 尝试练习 1 和 2，看看如果这些函数省略锁会发生什么。 您可能会发现很难触发不正确的行为，这表明很难可靠地测试代码是否没有锁定错误和竞争。 xv6 有一些竞争并非不可能。

使用锁的一个困难部分是决定使用多少锁以及每个锁应该保护哪些数据和不变量。 有几个基本原则。 首先，任何时候一个 CPU 可以同时写入一个变量，而另一个 CPU 可以读取或写入它，应该使用锁来防止两个操作重叠。 其次，请记住锁保护不变量：如果一个不变量涉及多个内存位置，通常所有这些位置都需要由一个锁保护以确保不变量得到维护。

上面的规则只说了什么时候需要锁，而没有说什么时候不需要锁，而且为了提高效率重要的是不要锁太多，因为锁会降低并行度。如果并行性不重要，那么可以安排只有一个线程而不用担心锁。 一个简单的内核可以在多处理器上执行此操作，方法是拥有一个锁，该锁必须在进入内核时获取并在退出内核时释放（尽管诸如管道读取或等待之类的系统调用会带来问题）。 许多单处理器操作系统已使用这种方法转换为在多处理器上运行，有时称为“大内核锁”，但该方法牺牲了并行性：一次只有一个 CPU 可以在内核中执行。 如果内核执行任何繁重的计算，使用更大的一组更细粒度的锁会更有效，这样内核就可以同时在多个 CPU 上执行。

作为粗粒度锁定的一个例子，xv6 的 kalloc.c 分配器有一个由单个锁保护的单个空闲列表。 如果不同 CPU 上的多个进程同时尝试分配页面，则每个进程都必须通过自旋获取来等待轮到它。 自旋会降低性能，因为它不是有用的工作。 如果锁的争用浪费了 CPU 时间的很大一部分，也许可以通过将分配器设计更改为具有多个空闲列表（每个列表都有自己的锁）以允许真正的并行分配来提高性能。

作为细粒度锁定的一个例子，xv6 对每个文件都有一个单独的锁，因此操作不同文件的进程通常可以在不等待彼此的锁的情况下继续进行。 如果想要允许进程同时写入同一文件的不同区域，文件锁定方案可以做得更细粒度。 最终，锁定粒度决策需要由性能测量和复杂性考虑来驱动。

6.4 deadlock adn lock ordering

如果一块代码需要同时拥有多个锁，那么应该让其他需要相同锁的进程按照相同的顺序acquire这些锁，否则可能出现死锁。比如进程1和2都需要锁A和锁B，如果进程1先acquire了锁A，进程2acquire了锁B，那么接下来进程1需要acquire锁B，进程2需要acquire锁A，但是这两个都不能acquire到也无法release各自的锁，就会出现死锁。

由于`sleep`在xv6中的机制，xv6中有很多长度为2的lock-order。比如`consoleintr`中要求先获得`cons.lock`，当整行输入完毕之后再唤醒等待输入的进程，这需要获得睡眠进程的锁。xv6的文件系统中有一个很长的lock chain，如果要创建一个文件需要同时拥有文件夹的锁、新文件的inode的锁、磁盘块缓冲区的锁、磁盘驱动器的`vdisk_lock`的锁以及调用进程的`p->lock`的锁

<img src="G:\typora_image_store\image-20230108191440021.png" alt="image-20230108191440021" style="zoom:80%;" />

除了lock ordering之外，锁和中断的交互也可能造成死锁。比如当`sys_sleep`拥有`tickslock`时，发生定时器中断，定时器中断的handler也需要acquire`tickslock`，就会等待`sys_sleep`释放，但是因为在中断里面，只要不从中断返回`sys_sleep`就永远无法释放，因此造成了死锁。对这种死锁的解决方法是：如果一个中断中需要获取某个特定的spinlock，那么当CPU获得了这个spinlock之后，该中断必须被禁用。xv6的机制则更加保守：当CPU获取了任意一个lock之后，将disable掉这个CPU上的所有中断（其他CPU的中断保持原样）。当CPU不再拥有spinlock时，将通过`pop_off`重新使能中断。

6.5 re-entrant locks

使用可重入锁（也称为递归锁）似乎可以避免某些死锁和锁排序挑战。 这个想法是，如果锁被一个进程持有并且如果该进程试图再次获取锁，那么内核可以只允许这样做（因为进程已经拥有锁），而不是像 xv6 内核那样调用 panic 。

然而，事实证明，可重入锁使并发推理变得更加困难：可重入锁打破了锁导致关键部分相对于其他关键部分是原子的直觉。 考虑以下两个函数 f 和 g：

```c
struct spinlock lock;
int data = 0;
f(){
    acquire(&lock);
    if(data == 0){
        call_once();
        h();
        data = 1;
    }
    release(&lock);
}

g(){
    acquire(&lock);
    if(data == 0){
        call_once();
        data = 1;
    }
    release(&lock);
}
```

查看此代码片段，直觉是 call_once 只会被调用一次：由 f 或 g，但不会同时被两者调用。

但是如果允许重入锁，h恰好调用了g，call_once就会被调用两次。
如果不允许重入锁，那么 h 调用 g 会导致死锁，这也不是很好。 但是，假设调用 call_once 是一个严重的错误，死锁是更可取的。 内核开发人员会观察到死锁（内核恐慌 kernel panics）并可以修复代码以避免它，而两次调用 call_once 可能会默默地导致难以追踪的错误。

为此，xv6 使用了更简单易懂的不可重入锁。 然而，只要程序员记住锁定规则，任何一种方法都可以工作。 如果 xv6 要使用可重入锁，则必须修改 acquire 以注意到锁当前由调用线程持有。 还必须以类似于 push_off 的方式向结构自旋锁添加嵌套获取的计数，这将在接下来讨论。

6.6 locks and interrupt handlers

一些 xv6 自旋锁保护线程和中断处理程序使用的数据。 例如，clockintr 计时器中断处理程序可能会在内核线程读取 sys_sleep 中的滴答声的同时递增滴答声 (kernel/trap.c:163)。 锁 tickslock 序列化这两个访问。

自旋锁和中断的相互作用会引发潜在的危险。 假设 sys_sleep 持有 tickslock，其 CPU 被定时器中断中断。 clockintr 会尝试获取 tickslock，看到它被持有，并等待它被释放。 在这种情况下，ticklock 将永不释放：只有 sys_sleep 可以释放它，但 sys_sleep 不会继续运行，直到 clockintr 返回。 所以 CPU 会死锁，任何需要锁的代码也会冻结。

为避免这种情况，如果中断处理程序使用自旋锁，则 CPU 绝不能在启用中断的情况下持有该锁。 xv6 更保守：当 CPU 获取任何锁时，xv6 总是禁用该 CPU 上的中断。 中断仍然可能发生在其他 CPU 上，因此中断的获取可以等待线程释放自旋锁； 只是不在同一个CPU上。

xv6 在 CPU 没有自旋锁时重新启用中断； 它必须做一点簿记来处理嵌套的关键部分。 acquire 调用 push_off (kernel/spinlock.c:89) 和 release 调用 pop_off (kernel/spinlock.c:100) 以跟踪当前 CPU 上锁的嵌套级别。 当该计数达到零时，pop_off 恢复存在于最外层临界区开始处的中断启用状态。 intr_off 和 intr_on 函数执行 RISC-V 指令以分别禁用和启用中断。

在设置 lk->locked (kernel/spinlock.c:28) 之前严格获取调用 push_off 是很重要的。 如果两者颠倒，则在启用中断的情况下保持锁定时会有一个短暂的窗口，不幸的是定时中断会使系统死锁。 同样重要的是release只有在释放锁后才调用pop_off。

6.7 intruction and memory ordering

人们很自然地认为程序是按照源代码语句出现的顺序执行的。 然而，许多编译器和 CPU 会乱序执行代码以实现更高的性能。 如果一条指令需要多个周期才能完成，则 CPU 可能会提早发出该指令，以便它可以与其他指令重叠并避免 CPU 停顿。 例如，CPU 可能会注意到在串行指令序列中，A 和 B 并不相互依赖。 CPU 可能首先启动指令 B，因为它的输入在 A 的输入之前准备就绪，或者为了重叠执行 A 和 B。编译器可以通过在语句的指令之前为一个语句发出指令来执行类似的重新排序 在它之前的来源。

编译器和 CPU 在重新排序时遵循规则，以确保它们不会更改正确编写的串行代码的结果。 然而，这些规则确实允许重新排序，这会改变并发代码的结果，并且很容易导致多处理器上的错误行为。 CPU 的排序规则称为内存模型。

比如这段push的代码，如果编译器或者CPU把第4行对应的store移动到第6行release之后的某个点，那将是一场灾难：

```c
l = malloc(sizeof *l);
l -> data = data;
acquire(&listlock);
l -> next = list;
list = l;
release(&listlock);
```

如果发生这样的`re-ordering`，将有一个窗口，在此期间另一个 CPU 可以获取锁并观察更新的列表，但会看到一个未初始化的`list -> next`。

为了告诉硬件和编译器不要执行此类重新排序，xv6 在获取 (kernel/spinlock.c:22) 和释放 (kernel/spinlock.c:47) 中都使用了 __sync_synchronize()。 `__sync_synchronize()` 是一个内存屏障：它告诉编译器和 CPU 不要跨屏障重新排序加载或存储。 在几乎所有重要的情况下，xv6 的获取和释放强制顺序中的障碍，因为 xv6 在对共享数据的访问周围使用锁。

6.8 sleep locks

spinlock的两个缺点：1. 如果一个进程拥有一个锁很长时间，另外一个企图acquire的进程将一直等待。2. 当一个进程拥有锁的时候，不允许把当前使用的CPU资源切换给其他线程，否则可能导致第二个线程也acquire这个线程，然后一直无法切回到原来的线程，无法release锁，从而导致死锁。

xv6提供了一种*sleep-locks*，可以在试图`acquire`一个被拥有的锁时`yield` CPU。spin-lock适合短时间的关键步骤，sleep-lock适合长时间的锁。

6.9 real world

尽管对并发原语和并行性进行了多年研究，但使用锁进行编程仍然具有挑战性。 通常最好将锁隐藏在更高级别的构造（如同步队列）中，尽管 xv6 不这样做。 如果您使用锁编程，使用尝试识别竞争条件的工具是明智的，因为很容易错过需要锁的不变量。

大多数操作系统都支持 POSIX 线程 (Pthreads)，它允许用户进程在不同的 CPU 上同时运行多个线程。 Pthreads 支持用户级锁、屏障等。Pthread 还允许程序员有选择地指定锁应该是可重入的。

在用户级别支持 Pthreads 需要操作系统的支持。 例如，如果一个 pthread 在系统调用中阻塞，则同一进程的另一个 pthread 应该能够在该 CPU 上运行。 再举一个例子，如果一个 pthread 改变了它的进程的地址空间（例如，映射或取消映射内存），内核必须安排其他运行同一进程线程的 CPU 更新它们的硬件页表以反映地址空间的变化。不用原子指令也可以实现锁，但是代价高昂，而且大多数操作系统都使用原子指令。

如果许多 CPU 试图同时获取同一个锁，那么锁的开销可能很大。 如果一个 CPU 在其本地缓存中缓存了一个锁，而另一个 CPU 必须获取该锁，那么更新持有锁的缓存行的原子指令必须将该行从一个 CPU 的缓存移动到另一个 CPU 的缓存，也许 使缓存行的任何其他副本无效。 从另一个 CPU 的缓存中获取缓存行的成本可能比从本地缓存中获取缓存行的开销大几个数量级。

为了避免与锁相关的开销，许多操作系统使用无锁数据结构和算法。 例如，可以实现像本章开头那样的链表，它在列表搜索期间不需要锁，并且可以通过一条原子指令在列表中插入一个项目。 然而，无锁编程比锁编程更复杂； 例如，必须担心指令和内存的重新排序。 用锁编程已经很困难了，所以 xv6 避免了无锁编程的额外复杂性。

7. scheduling

任何操作系统运行的进程都可能多于计算机的 CPU，因此需要一个计划来在进程之间分时分配 CPU。理想情况下，共享对用户进程是透明的。 一种常见的方法是通过将进程多路复用到硬件 CPU 上，为每个进程提供它拥有自己的虚拟 CPU 的错觉。 本章解释 xv6 如何实现这种多路复用。

7.1 multiplexing

xv6 通过在两种情况下将每个 CPU 从一个进程切换到另一个进程来实现多路复用。 首先，xv6 的睡眠和唤醒机制在进程等待设备或管道 I/O 完成时切换，或者等待子进程退出，或者在睡眠系统调用中等待。 其次，xv6 周期性地强制切换以应对长时间不休眠计算的进程。 这种多路复用创造了每个进程都有自己的 CPU 的错觉，就像 xv6 使用内存分配器和硬件页表来创造每个进程都有自己的内存的错觉一样。

实施多路复用会带来一些挑战。 一、如何从一个进程切换到另一个进程？ 虽然上下文切换的想法很简单，但是实现是 xv6 中一些最不透明的代码。 第二，如何以对用户进程透明的方式强制切换？ Xv6 使用硬件定时器中断驱动上下文切换的标准技术。 第三，所有 CPU 在同一共享进程集之间切换，并且需要锁定计划来避免竞争。第四，进程退出时必须释放进程的内存和其他资源，但它不能自己完成所有这些，因为（例如）它无法在仍在使用它的同时释放自己的内核堆栈。 第五，多核机器的每个核心都必须记住它正在执行哪个进程，以便系统调用影响正确进程的内核状态。 最后，sleep 和 wakeup 允许一个进程放弃 CPU 并等待被另一个进程或中断唤醒。需要注意避免导致唤醒通知丢失的竞争。 Xv6 试图尽可能简单地解决这些问题，但是生成的代码却很棘手。

<img src="G:\typora_image_store\image-20230108203818130.png" alt="image-20230108203818130" style="zoom:80%;" />

7.2 code : context switching

上图概述了一个用户进程切换到另一个用户进程所涉及的步骤，用户内核转换（系统调用或中断）到旧的内核线程。上下文切换到当前 CPU 的调度程序线程，上下文切换到新进程的内核线程，陷阱返回到用户级进程。 xv6 调度器每个 CPU 都有一个专用线程（保存的寄存器和堆栈），因为调度器在旧进程的内核堆栈上执行是不安全的：其他一些核心可能会唤醒进程并运行它，这将是一场灾难 在两个不同的内核上使用相同的堆栈。 在本节中，我们将研究在内核线程和调度程序线程之间切换的机制。

从一个线程切换到另一个涉及保存旧线程的 CPU 寄存器，并恢复新线程先前保存的寄存器； 堆栈指针和程序计数器被保存和恢复的事实意味着 CPU 将切换堆栈并切换它正在执行的代码。

函数 `swtch` 执行内核线程切换的保存和恢复。 swtch 不直接了解线程； 它只是保存和恢复 32 个 RISC-V 寄存器集，称为上下文。当进程放弃 CPU 时，进程的内核线程调用 swtch 来保存自己的上下文并返回到调度程序上下文。 每个上下文都包含在结构上下文 (kernel/proc.h:2) 中，它本身包含在进程的 struct proc 或 CPU 的 struct cpu 中。 swtch 有两个参数：`struct context *old` 和 `struct context *new`。 它将当前寄存器保存在旧寄存器中，从新寄存器中加载寄存器，然后返回。

让我们通过 swtch 进入调度程序来跟踪一个过程。 我们在第 4 章中看到，中断结束时的一种可能性是 usertrap 调用 yield。 yield依次调用sched，sched调用swtch将当前上下文保存在`p->context`中，并切换到之前保存在`cpu->scheduler`(kernel/proc.c:490)中的scheduler上下文。

swtch (kernel/swtch.S:3) 只保存被调用者保存的寄存器； C 编译器在调用者中生成代码以将调用者保存的寄存器保存在堆栈中。 swtch 知道每个寄存器字段在结构上下文中的偏移量。 它不保存程序计数器。 相反，swtch 保存 ra 寄存器，它保存调用 swtch 的返回地址。 现在 swtch 从新的上下文中恢复寄存器，该上下文保存由先前的 swtch 保存的寄存器值。 当swtch返回时，返回到恢复的ra寄存器指向的指令，也就是新线程之前调用swtch的指令。 此外，它返回新线程的堆栈，因为那是恢复的 sp 指向的地方。

在我们的示例中，sched 调用 swtch 以切换到 cpu->scheduler，即每个 CPU 的调度程序上下文。 该上下文是在过去调度程序调用 swtch (kernel/proc.c:456) 切换到现在正在放弃 CPU 的进程时保存的。 当我们一直跟踪的 swtch 返回时，它返回的不是 sched，而是 scheduler，栈指针在当前 CPU 的调度程序栈中。

```c
void sched(void)
{
    int intena;
    struct proc *p = myproc();
    if(!holding(&p ->lock)){
        panic("sched p -> lock");
    if(mycpu()->noff != 1)
    	panic("sched locks");
    if(p->state == RUNNING)
    	panic("sched running");
    if(intr_get())
    	panic("sched interruptible");

  	intena = mycpu()->intena;
  	swtch(&p->context, &mycpu()->context);
  	mycpu()->intena = intena;
    }
}
```

7.3 code :scheduling(调度器)

最后一节介绍了 swtch 的底层细节； 现在让我们将 swtch 作为给定的并检查通过调度程序从一个进程的内核线程切换到另一个进程。 调度器以每个 CPU 一个特殊线程的形式存在，每个线程都运行调度器函数。 该函数负责选择下一步要运行的进程。 想要放弃 CPU 的进程必须获得自己的进程锁 p->lock，释放它持有的任何其他锁，更新自己的状态 (p->state)，然后调用 sched。 您可以在 yield (kernel/proc.c:496)、sleep 和 exit 中看到这个序列。 Sched 仔细检查了其中一些要求 (kernel/proc.c:480-485)，然后检查了一个含义：由于持有锁，因此应该禁用中断。 最后sched调用swtch将当前上下文保存在p->context中，切换到cpu->scheduler中的scheduler上下文。 Swtch 返回调度程序的堆栈，就好像调度程序的 swtch 已经返回一样。调度程序继续其 for 循环，找到要运行的进程，切换到它，然后循环重复。

```c
void scheduler(void)
{
    struct proc *p;
    struct cpu *c = mycpu();
    c -> proc = 0;
    for(;;){
        intr_on();
        for(p = proc; p < &proc[NPROC]; p ++){
            acquire(&p -> lock);
            if(p -> state == RUNNABLE){
                // switch to chosen process. It is the process's job
                // to release  its lock and then reacquire it
                // before jumping back to us.
                p -> state = RUNNING;
                c -> proc = p;
                swtch(&c -> context, &p -> context);
                // process is done running for now
                // it should have changed its p -> state before coming back
                c -> proc = 0;
            }
            release(&p -> lock);
        }
    }
}
```

我们刚刚看到 xv6 在对 swtch 的调用中持有 p->lock：swtch 的调用者必须已经持有锁，并且锁的控制传递给切换到的代码。 这种约定对于锁是不常见的； 通常获取锁的线程也负责释放锁，这样更容易判断正确性。 对于上下文切换，有必要打破这个约定，因为 p->lock 保护进程状态和上下文字段的不变量
在 swtch 中执行时不正确。 如果 p->lock 在 swtch 期间未保持，则可能出现的一个问题示例：不同的 CPU 可能会在 yield 将其状态设置为 RUNNABLE 之后但在 swtch 导致它停止使用自己的内核堆栈之前决定运行该进程。 结果将是两个 CPU 在同一个堆栈上运行，这将导致混乱。

内核线程放弃其 CPU 的唯一地方是在 sched 中，它总是切换到调度程序中的相同位置，调度程序（几乎）总是切换到以前调用 sched 的某个内核线程。 因此，如果要打印出 xv6 切换的行号线程，人们会观察到以下简单模式：(kernel/proc.c:456), (kernel/proc.c:490), (kernel/proc.c:456), (kernel/proc.c:490), 等等。 有意通过线程切换将控制转移给彼此的过程有时称为协程； 在这个例子中，sched 和 scheduler 是彼此的协程。

有一种情况是调度程序对 swtch 的调用没有在 sched 中结束。 allocproc 将新进程的上下文 ra 寄存器设置为 forkret (kernel/proc.c:508)，以便它的第一个 swtch “返回”到该函数的开始。 Forkret 的存在是为了释放 p->lock； 否则，因为新进程需要像从 fork 返回一样返回到用户空间，它可以改为从 usertrapret 开始。

调度程序（kernel/proc.c:438）运行一个循环：找到一个要运行的进程，运行它直到它yield，repeat。 调度程序循环遍历进程表以寻找可运行的进程，一个具有 p->state== RUNNABLE 的进程。 一旦找到进程，它就会设置每个 CPU 当前进程变量 c->proc，将进程标记为 RUNNING，然后调用 swtch 开始运行 (kernel/proc.c:451-456)。

考虑调度代码结构的一种方法是，它对每个进程强制执行一组不变量，并在这些不变量不正确时保持 p->lock。 一个不变的是，如果一个进程正在运行，定时器中断的收益必须能够安全地从该进程切换出去； 这意味着 CPU 寄存器必须保存进程的寄存器值（即 swtch 没有将它们移动到上下文中），并且 c->proc 必须引用进程。 另一个不变量是，如果一个进程是 RUNNABLE 的，那么空闲 CPU 的调度程序运行它必须是安全的； 这意味着 p->context 必须保存进程的寄存器（即，它们实际上不在真实寄存器中），没有 CPU 在进程的内核堆栈上执行，并且没有 CPU 的 c->proc 引用该进程。 请注意，当 p->lock 被持有时，这些属性通常不成立。

保持上述不变量是 xv6 经常在一个线程中获取 p->lock 并在另一个线程中释放它的原因，例如在 yield 中获取并在 scheduler 中释放。 一旦 yield 开始修改正在运行的进程的状态以使其成为 RUNNABLE，锁必须保持
保持到不变量恢复：最早的正确释放点是在调度程序（在其自己的堆栈上运行）清除 c->proc 之后。 同样，一旦调度程序开始将一个 RUNNABLE 进程转换为 RUNNING，直到内核线程完全运行（在 swtch 之后，例如在 yield 中），才能释放锁。

7.4 code: mycpu and myproc

xv6 通常需要一个指向当前进程的 proc 结构的指针。 在单处理器上，可以有一个指向当前进程的全局变量。 这在多核机器上不起作用，因为每个核心执行不同的进程。 解决这个问题的方法是利用每个内核都有自己的一组寄存器这一事实； 我们可以使用其中一个寄存器来帮助查找每个核心的信息。

xv6 为每个 CPU 维护一个 struct cpu (kernel/proc.h:22)，它记录当前在该 CPU 上运行的进程（如果有的话），为 CPU 的调度程序线程保存的寄存器，以及管理中断所需的嵌套自旋锁的数量 禁用。 函数 mycpu (kernel/proc.c:72) 返回指向当前 CPU 的 struct cpu 的指针。 RISC-V 给它的 CPU 编号，给每个 CPU 一个 hartid。 xv6 确保每个 CPU 的 hartid 在内核中存储在该 CPU 的 tp 寄存器中。这允许 mycpu 使用 tp 索引一组 cpu 结构以找到正确的那个。

确保 CPU 的 tp 始终保存 CPU 的 hartid 有点复杂。 mstart 在 CPU 启动序列的早期设置 tp 寄存器，同时仍处于机器模式 (kernel/start.c:51)。 usertrapret 将tp 保存在trampoline 页面中，因为用户进程可能会修改tp。 最后，uservec 恢复从用户空间进入内核时保存的 tp (kernel/trampoline.S:70)。 编译器保证永远不会使用 tp 寄存器。 如果 xv6 可以在需要时向 RISC-V 硬件询问当前的 hartid 会更方便，但 RISC-V 只允许在机器模式下，而不是在管理模式下。

cpuid 和 mycpu 的返回值是脆弱的：如果计时器中断并导致线程让步，然后转移到不同的 CPU，之前返回的值将不再正确。 为避免此问题，xv6 要求调用者禁用中断，并且仅在使用完返回的 struct cpu 后才启用它们。

函数 myproc (kernel/proc.c:80) 返回当前 CPU 上运行的进程的 struct proc 指针。 myproc 禁用中断，调用 mycpu，从 struct cpu 中获取当前进程指针 (c->proc)，然后启用中断。 即使启用了中断，myproc 的返回值也可以安全使用：如果定时器中断将调用进程移动到不同的 CPU，其 struct proc 指针将保持不变。

7.5 sleep and wakeup

调度和锁有助于从另一个线程中隐藏一个线程的操作，但我们还需要帮助线程有意交互的抽象。 例如，xv6 中管道的读取器可能需要等待写入进程产生数据；父进程需要等待子进程退出，而读取磁盘的进程需要等待磁盘硬件完成读取。 xv6 内核在这些情况下（以及许多其他情况下）使用称为睡眠和唤醒的机制。 睡眠允许内核线程等待特定事件； 另一个线程可以调用唤醒来指示等待事件的线程应该恢复。 睡眠和唤醒通常称为序列协调或条件同步机制。

睡眠和唤醒提供了一个相对低级的同步接口。 为了激发它们在 xv6 中的工作方式，我们将使用它们来构建一个更高级别的同步机制，称为信号量，用于协调生产者和消费者（xv6 不使用信号量）。 信号量维护一个计数并提供两个操作。 “V”操作（对于生产者）增加计数。 “P”操作（对于消费者）等待计数不为零，然后递减计数并返回。 如果只有一个生产者线程和一个消费者线程，并且它们在不同的 CPU 上执行，并且编译器没有过度优化，那么这个实现是正确的：

```c
struct semaphore {
    struct spinlock lock;
    int count;
};
void V(struct semaphore *s){
    acquire(&s -> lock);
    s -> count += 1;
    release(&s -> lock);
}
void P(struct semaphore *s){
    while(s -> count == 0){
        ;
        acquire(&s -> lock);
        s-> count -= 1;
        release(&s -> lock);
    }
}
```

上面的实现是昂贵的。 如果生产者很少行动，消费者将花费大部分时间在 while 循环中旋转，希望得到一个非零计数。 消费者的 CPU 可能会通过反复轮询 s->count 来找到比忙碌等待更有效率的工作。 避免忙等待需要一种方法让消费者让出 CPU 并仅在 V 增加计数后恢复。

这是朝着这个方向迈出的一步，但正如我们将看到的那样还不够。 让我们想象一对调用，sleep 和 wakeup，它们的工作方式如下。 Sleep(chan) 在任意值 chan 上休眠，称为等待通道。 Sleep 使调用进程进入睡眠状态，释放 CPU 用于其他工作。 Wakeup(chan) 唤醒所有在 chan 上休眠的进程（如果有），导致它们的睡眠调用返回。 如果没有进程在等待 chan，wakeup 什么都不做。 我们可以改变信号量使用睡眠和唤醒的实现：

```c
void V（struct semaphore *s){
    acquire(&s -> lock);
    s -> count ++;
    wakeup(s);
    release(&s -> lock);
}
void P(struct semaphore *s){
    while(s -> count == 0){
        sleep(s);
        acquire(&s -> lock); //
        s -> count --;
        release(&s -> lock);
    }
}
```

P 现在放弃了 CPU 而不是自旋，这很好。 然而，事实证明，在不遭受所谓的丢失唤醒问题的情况下使用此接口设计睡眠和唤醒并不是一件容易的事。 假设 P 在第 212 行发现 s->count == 0。当 P 在第 212 行和第 213 行之间时，V 在另一个 CPU 上运行：它将 s->count 更改为非零并调用 wakeup，这发现没有进程在休眠并且 因此什么都不做。现在 P 在第 213 行继续执行：它调用睡眠并进入睡眠状态。 这导致了一个问题：P 在等待已经发生的 V 调用时处于睡眠状态。 除非我们很幸运并且生产者再次调用 V，否则即使计数不为零，消费者也会永远等待。这个问题的根源在于，P 仅在 s->count == 0 时才休眠的不变量被在错误时刻运行的 V 所违反。 保护不变量的错误方法是移动 P 中的锁获取（下面以黄色突出显示），以便它对计数的检查和对睡眠的调用是原子的：

人们可能希望这个版本的 P 会避免丢失唤醒，因为锁阻止了 V 在第 313 行和第 314 行之间执行。它做到了这一点，但它也会死锁：P 在休眠时持有锁，因此 V 将永远阻塞等待锁。

我们将通过改变sleep的接口来修复上述方案：调用者必须将条件锁传递给sleep，以便在调用进程被标记为睡眠并等待睡眠通道后释放锁。 锁将强制并发 V 等待，直到 P 完成让自己进入睡眠状态，以便唤醒将找到睡眠中的消费者并将其唤醒。 一旦消费者再次醒来， sleep 在返回之前重新获取锁。 我们新的正确睡眠/唤醒
方案可按如下方式使用（更改以黄色突出显示）：

```c
void V（struct semaphore *s){
    acquire(&s -> lock);
    s -> count ++;
    wakeup(s);
    release(&s -> lock);
}
void P(struct semaphore *s){
    while(s -> count == 0){
        sleep(s, &s -> lock);//
        acquire(&s -> lock); 
        s -> count --;
        release(&s -> lock);
    }
}
```

P 持有 s->lock 的事实阻止了 V 在 P 检查 c->count 和调用睡眠之间尝试唤醒它。 但是请注意，我们需要 sleep 以原子方式释放 s->lock 并将消费进程置于睡眠状态，以避免丢失唤醒。
