《xv6: a simple, Unix-like teaching operating system》

一、 操作系统接口（Operating system interfaces）

操作系统的工作是在多个程序之间共享一台计算机，并提供一个比硬件本身支持的更有用的服务集，操作系统在多个程序之间共享硬件资源，以便它们（看似）同时运行，操作系统为程序交互提供受控方式，以便它们可以共享数据或者协同工作。

<img src="G:\typora_image_store\image-20221216124255467.png" alt="image-20221216124255467" style="zoom:80%;" />

每个运行的程序称之为进程，由包含指令的内存，数据和栈组成。指令实行程序的计算，数据交由计算执行，栈管理程序的调度。当一个进程需要唤醒一个kernel服务，它就唤醒了一个system call，每个system call 进入内核，内核完成服务并返回。kernel使用了硬件保护机制提供给CPU，确保每个进程在自己的用户空间只能访问自己的内存。用户程序执行时没有这种特权，当一个用户程序唤醒一个系统调用时，硬件会提升权限并开始执行预先在内核中排序好的程序。内核提供的系统调用集合是用户程序看到的接口。

shell是一个原生的程序用来读取指令并执行。实际上，shell是一个用户程序，而不是内核的一部分。

1.1 processes and memory

xv6包含用户空间内存（指令、数据、栈），和内核私有的每个进程状态。当进程不再执行时xv6将存储和这些进程相关的CPU寄存器直到下一次运行这些进程，内核通过PID连接每个进程。

`int fork()`：一个进程可以通过fork创建一个新的进程，提供相同的内存上下文包括指令和数据，父进程返回子进程的PID，子进程返回0。

```c
int pid = fork();  //fork之后，父子进程同时开始判断pid的值，看哪个进程先判断好pid才会决定输出顺序。
printf("pid=%d\n", pid);
if(pid > 0){
	printf("parent: child=%d\n", pid);
	pid = wait((int *) 0); //父进程发现子进程exit之后，wait执行完毕，打印输出。
	printf("child %d is done\n", pid);
} else if(pid == 0){
	printf("child: exiting\n");
	exit(0);  //子进程在判断pid==0之后将exit,
} else {
	printf("fork error\n");
}

---
输出：
pid=2018356
parent:child=2018356
pid=0
child:existing
child 2018356 is done  //当子进程退出后，父进程的wait就会返回。

```

`int exit(int status)`: 系统调用会停止执行并释放资源,如内存和打开的文件,需要一个整型的状态参数，返回值0表示正常状态退出，1表示非正常状态退出。

`int wait(int *status)`：系统调用返回当前进程被停止或被杀掉的子进程的状态，返回子进程的PID， 子进程的退出状态存储到 int *status这个地址中，并将状态码拷贝到内存中等待。如果调用者没有子进程，wait立即返回-1，如果父进程不在乎子进程的退出态，它可以给一个0地址给wait。父进程和子进程有着相同的内存上下文，但是在不同的内存和寄存器中执行。改变一个并不会改变另一个。如当wait的返回值被父进程存储到pid中时，它不会改变子进程中变量pid中的值，子进程中的变量pid的值还是0。

`int exec(char *file, char *argv[])`:加载一个文件，获取执行它的参数，执行，如果执行错误返回-1，执行成功不返回，而是开始从文件入口位置开始执行命令。文件必须有一个特殊的格式，必须指明哪一部分是保存指令，哪一部分是数据。xv6使用的是ELF文件格式，当exec成功时，他不会返回给调用程序，相反，从文件加载的指令在 ELF 标头中声明的入口点开始执行。exec输入两个参数：文件包含的可执行文件名和一组参数。

```c
//xv6 shell使用以上四个system call来为用户执行程序。在shell进程的main中主循环先通过getcmd来从用户获取命令，然后调用fork来运行一个和当前shell进程完全相同的子进程。父进程调用wait等待子进程exec执行完（在runcmd中调用exec）

char *argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
//---------------------------------------------------
int main(){
    static char buf[100];
    int fd;
    // ensure that three file descriptions are open.
    while(fd = open("console", O_RDWR ) >= 0){
        if(fd >= 3){
            close(fd);
            break;
        }
    }
    // read and run input commands
    while(getcmd(buf, sizesof(buf)) >= 0){
        if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
            // chdir must be called by the parent, not the child.
            buf[strlen(buf) - 1] = 0;
            if(chdir(buf + 3) < 0)
                fprintf(2, "cannot cd %s\n", buf + 3);
            continue;
        }
        if(fork1() == 0)
            runcmd(parsecmd(buf));
        wait(0);
    }
    exit(0);
}
```

避免创建重复进程然后立即替换它的浪费,操作内核通过使用虚拟内存技术（如写时复制）优化此用例的 fork 实现。xv6 隐式分配大部分用户空间内存：fork 分配父内存的子副本所需的内存，exec 分配足够的内存来保存可执行文件。在运行时需要更多内存的进程（可能是 `malloc`）可以调用 `sbrk(n)` 将其数据内存增加 n 字节； `sbrk` 返回新内存的位置。

1.2 输入输出和文件描述符 (I/O and File descriptors)

文件描述符时用来表征一个进程将从那里读取或者写入到哪里的内核管理对象。一个进程可以通过打开一个文件、目录或设备或创建一个管道，或复制一个已经存在的描述符。文件描述符接口抽象了文件、管道和设备之间的差异，使它们看起来都像字节流。xv6 内核使用文件描述符作为每个进程表的索引，因此每个进程都有一个从零开始的文件描述符的私有空间。每个进程都拥有自己独立的文件描述符列表，**其中0是标准输入，1是标准输出，2是标准错误**。shell将保证总是有3个文件描述符是可用的。

`int read(int fd,char * buf,int n)`; 从文件描述符fd中读取n字节的数据拷贝到buf中，**返回值是读取的字节数**。每个文件描述符都有一个与之相关的offset。read 从当前文件偏移量读取数据，然后将该偏移量增加读取的字节数，下一个read将从新的offset开始读取字节，当没有更多的字节可以读取时，read返回0来表示读取到文件的结束。

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

#define MSGSIZE 16
int main(int argc, char * argv[]){
    char buf[MEGSIZE];
    read(0, buf, MSGSIZE); //获取前一个命令的标准化输出，即当前命令的标准化输入
    printf("获取到的标准化输入:%s\n", buf);
    exit(0);
}
```

`int write(int fd, char *buf,int n)`；从buf中写入n字节的数据到文件描述符fd中，返回值是有多少的字节数据被写入。当少于n个字节的数据被写入时互出现错误，通read一样存在偏移量。

```c
//cat命令的实现
char buf[512];
int n;
for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0) break;
    if(n < 0){
        fprintf(2, "read error\n");
        exit(1);
    }
    if(write(1, buf, n) != n){
        fprintf(2, "write error\n");
        exit(1);
    }
}
```

`int close(int fd)`:系统调用，释放一个文件描述符，让它变得可以被未来的open pipe 或者dup系统调用使用。

fork拷贝父进程的文件描述符到自己的内存空间中，因此子进程可以像父进程一样打开文件，exec代替了调用进程的内存，但是将它保留在文件表中。父进程的fd table将不会被子进程fd table的变化影响，但是文件中的offset将被共享。

```c
// cat 命令的实现 cat < input.txt
char *argv[2];
argv[0] = "cat";
argv[1] = 0;
if(fork() == 0){
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
```

关键字： O_RDONLY：打开文件for reading, OWRONLY:打开文件for writting, , ORDWR:打开文件for reading and writting , O_CREATE:如果文件不存在，就创造它, O_TRUNC：将文件截断到0的长度。

`int dup(int fd)`:系统调用，返回一个引用相同底层 I/O 对象的新对象。两个文件描述符共享一个偏移量，就像 fork 复制的文件描述符一样。

```c
// another way to write hello world
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
```

如果两个文件描述符是通过一系列 fork 和 dup 调用从同一个原始文件描述符派生的，则它们共享一个偏移量,否则文件描述符不共享偏移量，即使它们来自对同一文件的打开调用.Dup 允许shell去实现一个这样的命令： ls existing-file non-existing-file > tmp1 2 >&1, 2>&1 告诉 shell 给命令一个文件描述符 2，它是描述符 1 的副本。现有文件的名称和不存在文件的错误消息都将显示在文件 tmp1 中.xv6 shell 不支持错误文件描述符的 I/O 重定向，但现在你知道如何实现它了。

1.3管道

管道是一个小的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。将数据写入管道的一端使该数据可用于从管道的另一端读取。 管道为进程提供了一种通信方式。（FIFO实现）

`int pipe(int p[])`:p[0]为读取的fd,p[1]为写入的fd。

```c
//以下示例代码运行程序 wc，标准输入连接到管道的读取端。
int p[2];
char *argv[2];
argv[0] = "wc";
argv[1] = 0;
pipe(p);
if(fork() == 0){
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    exec("/bin/wc", argv);
}else {
    close(p[0]);
    write(p[1], "hello world\n", 12);
    close(p[1]);
}
//这段程序叫做pipe，它创造了一个新的管道来记录读和写的文件描述符在数组p中。，在fork之后，父进程和子进程都会有文件描述符指向这个管道，子进程调用close和dup来让文件描述符0引用管道的读取端，关闭文件描述符，之后调用exec执行wc指令，当wc读取它的标准输入时，它从管道读取，父进程关闭了管道的读取端，写管道，然后关闭写端。
```

如果没有数据可用，则管道上的读取等待写入数据或关闭引用写入端的所有文件描述符； 在后一种情况下，read 将返回 0，就像已到达数据文件的末尾一样。 读取阻塞直到新数据不可能到达的事实是子进程在执行上面的 wc 之前关闭管道的写入端很重要的一个原因：如果 wc 的文件描述符之一引用了写入端管道，wc永远看不到文件结束。

xv6的shell实现一个这样的命令： grep fork sh.c | wc -l，子进程创建一个管道来连接管道的左端和右端。之后在管道左端调用fork和runcmd指令，在管道右端调用fork和runcmd指令在管道的右端，然后等待两边都结束。管道的右端可能是一个命令，它本身包含一个管道（例如，a | b | c），它本身会派生两个新的子进程（一个用于 b，一个用于 c）。因此，shell 可以创建一个进程树。这棵树的叶子节点是命令，内部节点是等待左右子节点完成的进程。原则上，可以让内部节点运行在管道的左端，但如果这样做正确的话会使实施变得复杂。考虑仅进行以下修改：
将 sh.c 更改为不分叉 p->left 并在内部进程中运行 runcmd(p->left)。之后例如：例如，echo hi | wc不会产生输出，因为在runcmd中echo hi退出时，内部进程退出，从不调用fork运行右端管道,这种不正确的行为可以通过不在 runcmd 中为内部进程调用 exit 来修复，但此修复使代码复杂化：现在 runcmd 需要知道它是否在内部进程中。当不分叉 runcmd(p->right) 时也会出现并发症。例如，仅进行该修改，sleep 10 | echo hi 将立即打印“hi”和一个新提示，而不是在 10 秒后； 发生这种情况是因为 echo 立即运行并退出，而不是等待 sleep 完成。由于 sh.c 的目标是尽可能简单，它不会试图避免创建内部进程。

在这种情况下，管道比临时文件至少有四个优势。第一：管道会自动清理自己，使用文件重定向，shell必须小心删除/tmp/xyz当它执行完成后。其次，管道可以传递任意长的数据流，而文件重定向需要磁盘上有足够的可用空间来存储所有数据。 第三、管道允许管道并行执行阶段，而文件方法要求第一个程序在第二个程序开始之前完成。 第四，如果你正在实现进程间通信，管道的阻塞读写比文件的非阻塞语义更高效。

1.4文件系统

xv6 文件系统提供数据文件，其中包含未解释的字节数组和目录，其中包含对数据文件和其他目录的命名引用。这些目录形成一棵树，从称为root的特殊目录开始。不以 / 开头的路径是相对于调用进程的当前目录进行评估的，该目录可以通过 chdir 系统调用进行更改。这两个代码片段都打开同一个文件（假设所有涉及的目录都存在).

```c
chdir("/a");
chdir("b");
open("c", O_RDONLY);
open("/a/b/c", O_RDONLY);
//第一个片段将进程的当前目录更改为/a/b； 第二个既不引用也不更改进程的当前目录。
```

有创建新文件和目录的系统调用：mkdir 创建新目录，使用 O_CREATE 标志打开创建新数据文件，mknod 创建新设备文件。 这个例子说明了所有三个：

```c
mkdir("/dir");
fd = open("/dir/file", O_CREATE|O_WRONLY);
close(fd);
mknod("/console", 1, 1);
```

`mknod` 创建一个引用设备的特殊文件.与设备文件相关联的是主设备号（major device）和次设备号(minor device),mknod 的两个参数，它们唯一地标识内核设备。当进程稍后打开设备文件时，内核将read和write系统调用转移到这个内核设备上，而不是将它们传递给文件系统。

文件名与文件本身不同； 同一个底层文件，称为索引节点（inode），可以有多个名称，称为links。每个链接都包含目录中的一个条目； 该条目包含一个文件名称和对 inode 的引用。inode 保存有关文件的元数据，包括其类型（文件或目录或设备）、长度、文件内容在磁盘上的位置以及文件的链接数。

`int fstat(int fd, struct stat *st)` ：系统调用从文件描述符**fd**引用的 inode 检索信息，将inode中的相关信息存储到**st**中。执行成功返回0， 失败返回-1。在 stat.h (kernel/stat.h) 中定义为：

```c
#define  T_DIR 1
#define T_FILE 2
#define T_DEVICE 3
struct stat{
    int dev; //file system's disk device
    uint ino; //inode number
    short type; //type of file
    short nlink; // number of links to file
    uint64 size; //size of file in bytes
};
```

`link`:系统调用，创建一个指向同一个inode的文件名。`unlink`则是将一个文件名从文件系统中移除，只有当指向这个inode的文件名的数量为0时，这个inode以及其存储的文件内容才会被从硬盘上移除。 此片段创建一个名为 a 和 b 的新文件。

```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

从 a 读取或写入 a 与从 b 读取或写入相同。每个 inode 都由唯一的 inode 编号标识。在上面的代码序列之后，可以通过检查 fstat 的结果来确定 a 和 b 引用相同的底层内容：两者都将返回相同的 inode 号（ino），并且 nlink 计数将设置为 2.unlink 系统调用从文件系统中删除一个名称。 只有当文件的链接计数为零并且没有文件描述符引用它时，文件的索引节点和保存其内容的磁盘空间才会被释放。 从而添加 unlink("a")；到最后一个代码序列使 inode 和文件内容可访问为 b。

```c
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

是创建一个没有名称的临时 inode 的惯用方法，当进程关闭 fd 或退出时将被清理.

Unix 提供可从 shell 调用的文件实用程序作为用户级程序，例如 `mkdir`、`ln` 和 `rm`等。这种设计允许任何人通过添加新的用户级程序来扩展命令行界面。事后看来，这个计划似乎很明显，但在 Unix 时代设计的其他系统通常将此类命令内置到 shell 中（并将 shell 内置到内核中）。一个例外是 cd，它内置于 shell (user/sh.c:160) 中。 cd 必须更改 shell 本身的当前工作目录。 如果 cd 作为常规命令运行，则 shell 将派生一个子进程，子进程将运行 cd，而 cd 将更改子进程的工作目录。 父级（即 shell 的）工作目录不会改变。

1.5 Real world

Unix 将“标准”文件描述符、管道和用于操作它们的方便的 shell 语法相结合，这是编写通用可重用程序的重大进步。 这个想法引发了一场 “软件工具”文化,也是 Unix 强大和流行的主要原因，而 shell 是第一个所谓的“脚本语言”。 Unix 系统调用接口今天在 BSD、Linux 和 macOS 等系统中仍然存在。Unix 系统调用接口已通过可移植操作系统接口 (POSIX) 标准进行了标准化。xv6 不符合 POSIX：它缺少许多系统调用（包括基本的系统调用，例如 lseek），并且它提供的许多系统调用与标准不同。 xv6 的主要目标是简单明了，同时提供简单的类 UNIX 系统调用接口。 为了运行基本的 Unix 程序，一些人用更多的系统调用和一个简单的 C 库扩展了 xv6。然而，与 xv6 相比，现代内核提供了更多的系统调用和更多种类的内核服务。 例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动程序等等。 现代内核不断快速发展，并提供许多超越 POSIX 的功能。

Unix 使用一组文件名和文件描述符接口统一访问多种类型的资源（文件、目录和设备）。 这个想法可以扩展到更多种类的资源；一个很好的例子是计划 9 [14]，它将“资源是文件”的概念应用于网络、图形等。然而，大多数 Unix 派生的操作系统并没有遵循这条路线。

文件系统和文件描述符是强大的抽象。 即便如此，还有其他操作系统接口模型。 Multics 是 Unix 的前身，它以一种使文件存储看起来像内存的方式抽象了文件存储，从而产生了一种截然不同的界面风格。 Multics 设计的复杂性直接影响了 Unix 的设计者，他们试图构建更简单的东西。

Xv6 不提供用户或保护一个用户免受另一个用户侵害的概念； 在 Unix 术语中，所有 xv6 进程都以 root 身份运行。

1.6 Exercises

“乒乓”：创建两个进程在管道的两端，父进程发送字节到子进程，子进程接收到字节打印自己的pid和recevied ping，然后通过管道写字节到父进程，父进程接收到后打印pid和recevied pong然后退出。

```c
#include"kernel/types.h"
#includeuser/user .h"
const int MESSAGE_SIZE = 7;
int main(int argc, char *argv[]){
    int fd[2];
    char buf[MESSAGE_SIZE];
    pipe(fd);
    int pid = fork();
    if(pid > 0){
        write(fd[1], "114514", 6);
        read(fd[0], buf, 6);
        printf("%d: received pong\n", getpid());
        exit(0);
    }else{
        read(fd[0], buf, 6);
        printf("%d: received ping\n", getpid());
        write(fd[1], "114514", 6);
        exit(0);
    }
}
```

素数筛法：使用pipe和fork实现流水线，将一组数范围为2到35喂入到一个进程中，先打印出最小的一个数，这个数是素数，之后用其他的数来除这个素数，如果可以整除则将其drop，不能整除的喂入到下一个进程，直到打印出所有的素数。





实现find：使用递归的方式找到指定的文件夹下的目标文件，参考user/ls.c实现方法：

```c
// hints:1.
struct dirent {
    ushort inum;
    char name[DIRSIZE];
}
//hints:2.
void *memmove(void *str1, const void *str2, size_t n);//从str2复制n个字符到str1，返回一个指向目标存储区str1的指针。
```





实现xargs：

`xargs`的作用是把stdin中的数据用空格或回车分割成命令行参数

例：`find .-name '*.py' | xargs cat | wc -l` :统计当前目录下所有python文件的总行数





二、operating system organization

2.1 Abatracting physical resources

​       在这个计划中，每个应用程序甚至可以有自己的库来满足其需求。应用程序可以直接与硬件资源交互，并以最适合应用程序的方式使用这些资源（例如，实现高性能或可预测的性能）。一些嵌入式设备的操作系统或者实时的操作系统就是以这种方式运行。这种库方法的缺点是，如果有多个应用程序在运行，则这些应用程序必须运行良好。例如：每个应用程序必须周期性的放弃对CPU资源的使用以便于其它程序可以调用。如果每个程序都足够相信对方并且没有bug这样的合作的时分复用机制可以很OK的工作。但是没有bug和相信对方是难以实现的，因此一个比这个方案提供更强的隔离方案需要被提出。

​	实现一个强隔离性的方案将资源抽象成服务，对于禁止应用程序直接访问敏感的硬件资源是非常有用的。如unix程序和存储的交互通过文件系统的open、read、write和close系统调用，而不是直接读写磁盘。这为应用程序提供了路径名的便利，并允许操作系统（作为接口的实现者）管理磁盘。即使隔离不是问题，有意交互（或只是希望彼此远离）的程序也可能会发现文件系统是比直接使用磁盘更方便的抽象。      	类似地，Unix 透明地在进程之间切换硬件 CPU，根据需要保存和恢复寄存器状态，因此应用程序不必知道时间共享。 这个透明度允许操作系统共享 CPU，即使某些应用程序处于无限状态循环。
​	另一个例子是，unix使用exec系统调用来构建自己的内存映像来代替直接和物理内存交互。这允许操作系统来决定在内存的哪里放置一个进程。如果内存紧张，操作系统内甚至可能会将进程的数据存储在磁盘上，exec还提供给用户一个方便的文件系统用来存储可执行的程序映像。
​	Unix 进程之间的许多形式的交互都是通过文件描述符发生的。 文件描述符不仅抽象出许多细节（例如，管道或文件中数据的存储位置），它们还以简化交互的方式定义。 例如，如果管道中的一个应用程序执行失败，内核会为管道中的下一个进程生成文件结束信号。

2.2 用户模式、超级模式、和系统调用

​	强隔离的实现需要在程序和系统调用之间有一个坚硬的边界。如果程序出错我们不希望操作系统和其他程序出现差错。而是希望操作系统能够清理这些出错的程序并继续执行其他的程序。为了实现这样的强隔离，操作系统必须安排让应用程序不能修改或读取操作系统的数据，并且应用程序不能访问其他的程序的内存。

​	CPU提供了这样的硬件支持。如RISC-V有三种让CPU执行的模式：machine mode, supervisor mode, user mode。在machine mode拥有最高的执行权力，CPU从该模式启动。用来配置计算机。XV6只在该模式下执行少量的程序然后切换到supevisor mode。

​	在supervisor mode下，CPU允许执行拥有特权的指令，例如：使能/失能中断，读写存储有page table的寄存器的值。如果应用程序在user mode想要执行特权的指令，CPU会禁止执行。一个应用程序只有在user mode下执行，如执行++i操作，在用户空间（user space）执行。在superivsor mode下执行的程序我们称之为运行在核空间（kernel space）。

一个用户态的程序想要唤醒一个核函数必须先进入到核空间，不能直接唤醒一个核函数。CPU 提供了一条特殊的指令，可以将 CPU 从用户模式（user mode）切换到管理员模式(supervisor mode)，并在内核指定的入口点进入内核（RISC-V提供了ecall指令用来完成这样的任务）。一旦CPU切换到supervisor mode，内核就会验证这些系统指令的参数（例如，检查传递给系统调用的地址是否是应用程序内存的一部分）从而决定是否允许应用程序执行请求的操作（例如，检查是否允许应用程序写入指定的文件），然后决定是拒绝它或执行它。内核控制转换到管理模式的入口点很重要； 例如，如果应用程序可以决定内核入口点，则恶意应用程序可以在跳过参数验证的位置进入内核。

2.3 kernel organization

一个关键的问题是操作系统在管理者模式下该运行什么程序。一种可能是整个操作系统驻留在内核中，因此所有的系统调用的实现都运行在管理者模式。这种模式称为单片内核（monolithic kernel）。在这种形势下，整个操作系统拥有整个的硬件权限。这种组织方式很方便，因为操作系统设计者不必决定操作系统的哪一部分不需要完整的硬件特权。此外，操作系统的不同部分更容易协作。例如，操作系统可能有一个缓冲区缓存，它可以由文件系统和虚拟内存系统共享。这种组织的额一个缺点是操作系统不同部分之间的接口通常很复杂，因此操作系统开发人员很容易犯错误。然而在这种模式下，一个错误的发生就会之致命的，因为在supervisor mode下的一个错误往往会导致内核失败，从而导致计算机停止工作。

​	为了降低内核出错的风险，操作系统设计人员可以最大限度地减少在管理员模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统。 这种内核组织称为微内核（micro kernel）。

<img src="G:\typora_image_store\image-20221222135547484.png" alt="image-20221222135547484" style="zoom:80%;" />

在图中，文件系统作为用户级进程运行。 作为进程运行的操作系统服务称为服务器。 为了允许应用程序与文件服务器进行交互，内核提供了一种进程间通信机制，可以将消息从一个用户模式进程发送到另一个用户模式进程。例如，如果像 shell 这样的应用程序想要读取或写入文件，它会向文件服务器发送消息并等待响应。在微内核中，内核接口由一些低级函数组成，用于启动应用程序、发送消息、访问设备硬件等。这种组织允许内核相对简单，因为大多数操作系统驻留在用户级服务器中。

​	在现实世界中，单体内核和微内核都很流行。 许多 Unix 内核是单一的。 例如，Linux 有一个单一的内核，尽管一些操作系统功能作为用户级服务器运行（例如，窗口系统）。 Linux 为操作系统密集型应用程序提供高性能，部分原因是内核的子系统可以紧密集成。 Minix、L4 和 QNX 等操作系统被组织为带有服务器的微内核，并且在嵌入式设置中得到了广泛部署。 L4 的变体 seL4 足够小，以至于它已经过内存安全和其他安全属性的验证。操作系统的开发人员之间存在很多争论，认为哪种组织更好，并且没有任何一种方式的确凿证据。 此外，它在很大程度上取决于“更好”的含义：更快的性能、更小的代码大小、内核的可靠性、整个操作系统（包括用户级服务）的可靠性等。还有一些实际考虑可能比哪个组织的问题更重要。 一些操作系统有一个微内核，但出于性能原因，在内核空间中运行一些用户级服务。 一些操作系统具有整体内核，因为它们是这样开始的，并且没有动力转向纯微内核组织，因为新功能可能比重写现有操作系统以适应微内核设计更重要。

​	与大多数 Unix 操作系统一样，Xv6 是作为一个整体内核实现的。 这样，xv6内核接口对应操作系统接口，内核实现了完整的操作系统。 由于 xv6 不提供很多服务，它的内核比一些微内核更小，但概念上 xv6 是整体的。

2.4 XV6 organization

<img src="G:\typora_image_store\image-20221222151954835.png" alt="image-20221222151954835" style="zoom:80%;" />

2.5 Process overview

xv6（和其他 Unix 操作系统一样）中的隔离单元是一个进程。进程抽象防止一个进程破坏或监视另一个进程的内存、CPU、文件描述符等。它还可以防止进程破坏内核本身，这样进程就无法破坏内核的隔离机制。内核必须小心地实现进程抽象，因为错误或恶意应用程序可能会诱使内核或硬件做一些坏事（例如，规避隔离）。内核用于实现进程的机制包括用户/管理员模式标志、地址空间和线程的时间片。

​	为了帮助加强隔离，进程抽象为程序提供了它拥有自己的私有机器的错觉。一个进程为程序提供了一个看似私有的内存系统或地址空间，其他进程无法读取或写入。 一个进程还为程序提供似乎是它自己的 CPU 来执行程序的指令。

​	xv6 使用页表（由硬件实现）为每个进程提供自己的地址空间。 RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换（或“映射”）为物理地址（CPU 芯片发送到主内存的地址）。

​	xv6 为每个定义进程地址空间的进程维护一个单独的页表。 如图 2.3 所示，地址空间包括从虚拟地址零开始的进程的用户内存。首先是指令，然后是全局变量，然后是堆栈，最后是进程可以根据需要扩展的“堆”区域（用于 malloc）。 有许多因素会限制进程地址空间的最大大小：RISC-V 上的指针是 64 位宽； 硬件在页表中查找虚拟地址时只使用低 39 位； 而 xv6 只使用了这 39 位中的 38 位。因此，最大地址为 238 − 1 = 0x3fffffffff，即MAXVA。在地址空间的顶部，xv6 保留了一个页面用于 trampoline 和一个映射进程的 trapframe 的页面。xv6 使用这两个页面来回转换到内核； trampoline 页面包含进出内核的代码，映射 trapframe 是保存/恢复用户进程状态所必需的，

​	xv6 内核为每个进程维护许多状态，并将其收集到一个 struct proc 中。进程最重要的内核状态部分是它的页表、内核堆栈和运行状态。 我们将使用符号 p->xxx 来指代 proc 结构的元素； 例如，p->pagetable 是指向进程页表的指针。

​	每个进程都有一个执行线程（或简称线程）来执行进程的指令。 一个线程可以被挂起并稍后恢复。为了在进程之间透明地切换，内核挂起当前运行的线程并恢复另一个进程的线程。 线程的大部分状态（局部变量、函数调用返回地址）都存储在线程的堆栈中。每个进程都有两个栈：用户栈和内核栈（p->kstack）。 当进程在执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核时（系统调用或中断），内核代码在进程的内核栈上执行； 当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，但不会被主动使用。进程的线程在主动使用其用户堆栈和内核堆栈之间交替。 内核堆栈是独立的（并且不受用户代码的影响），因此即使进程破坏了其用户堆栈，内核也可以执行。
​	进程可以通过执行RISC-V 的ecall指令进行系统调用。该指令提高硬件特权级别并将程序计数器更改为内核定义的入口点。入口点的代码切换到内核堆栈并执行完成系统调用的内核指令。当系统调用完成后护内核切换回用户栈，通过调用sret指令返回用户空间，降低硬件的特权级别，恢复执行系统调用指令的用户指令。进程的线程可以在内核中“阻塞”以等待I/O, 并在I/O完成后从中断恢复。

​	p->state 表示进程是否已分配、准备运行、运行、等待 I/O 或退出。

​	p->pagetable 以 RISC-V 硬件期望的格式保存进程的页表。

​	xv6 导致分页硬件在用户空间中执行该进程时使用该进程的 p->pagetable。 一个进程的页表同时也记录了分配给进程内存的物理页的地址。

​	总而言之，一个进程捆绑了两种设计思想：地址空间让进程产生自己内存的错觉，线程让进程产生自己的 CPU 错觉。 在 xv6 中，一个进程由一个地址空间和一个线程组成。 在真实的操作系统中，一个进程可能有多个线程来利用多个 CPU。

2.6 starting xv6, the first process and system call

​	为了使 xv6 更具体，我们将概述内核如何启动和运行第一个进程。 后续章节将更详细地描述本概述中出现的机制。

​	当 RISC-V 计算机开机时，它会自行初始化并运行存储在只读存储器中的引导加载程序。 引导加载程序将 xv6 内核加载到内存中。 然后，在机器模式下，CPU 从 _entry (kernel/entry.S:7) 开始执行 xv6。 RISC-V 从禁用分页硬件开始：虚拟地址直接映射到物理地址。

​	加载程序将 xv6 内核加载到物理地址 0x80000000 的内存中。 它将内核放在 0x80000000 而不是 0x0 的原因是因为地址范围 0x0:0x80000000 包含 I/O 设备.

​	_entry 处的指令设置了一个堆栈，以便 xv6 可以运行 C 代码。 Xv6 在文件 start.c 中为初始堆栈 stack0 声明了空间。 _entry 处的代码将堆栈指针寄存器 sp 加载到地址 stack0+4096，堆栈的顶部，因为 RISC-V 上的堆栈向下增长。 现在内核有了堆栈，entry 在开始时调用 C 代码。

​	函数 start 执行一些只允许在机器模式下进行的配置，然后切换到管理员模式。 为了进入管理模式，RISC-V 提供了指令 mret。 这个指令最常用于从先前的管理模式调用返回到机器模式。 start 不会从这样的调用中返回，而是将事情设置为好像有一个：它在寄存器 mstatus 中将先前的特权模式设置为主管，它通过将 main 的地址写入寄存器 mepc 来将返回地址设置为 main ，通过将 0 写入页表寄存器 satp 来禁用管理员模式下的虚拟地址转换，并将所有中断和异常委托给管理员模式。

​	在进入管理模式之前，start还执行一项任务，它对时钟芯片进行编程以生成定时器中断。完成这些任务处理后，通过调用mret开始“返回”到管理模式，这会导致程序计数器更改为main。在main初始化几个设备核子系统后，通过调用userinit创建第一个进程，第一个进程执行一个用RISC-V汇编编写的小程序，make进行xv6中的第一个系统调用，initcode.S将exec系统调用的编号SYS_EXEC加载到寄存器a7当中，然后调用ecall重新进入内核。

​	内核在系统调用中使用寄存器a7中的数字来调用所需的系统调用。系统调用将SYS_EXEC映射到内核调用的sys_exec。正如我们在第一章中看到的，exec用一个新程序代替了当前进程的内存和寄存器。

​	一旦内核完成exec之后，它就会在/init进程中返回到用户空间。如果需要，init会创建一个新的控制台设备文件，然后将其作为文件描述符0，1，2打开。然后它会在控制台上启动一个shell，此时系统就被启动了。

2.7 security model

您可能想知道操作系统如何处理错误或恶意代码。 因为处理恶意比处理意外错误要难得多，所以将这个主题视为与安全有关。 这是操作系统设计中典型安全假设和目标的高级视图。

​	操作系统必须假定进程的用户级代码会尽最大努力来破坏内核或其他进程。用户代码可能会尝试取消引用其与允许地址空间之外的指针空间，他可能会尝试执行任何RISC-V指令。即使是那些不打算用于用户代码的指令，他可能会尝试读写任何RISC-V控制寄存器，他可能会尝试直接访问设备硬件，他可能会将巧妙地值传递给系统调用，以试图诱使内核崩溃或做一些愚蠢的事情。内核的目标是限制每个用户进程，以便所有它可以做的事read/write/execute自己的用户内存。使用32位通用RISC-V寄存器，并以系统调用旨在允许的方式影响内核和其他进程。内核必须阻止任何其他操作，这通常事内核设计中的绝对要求。

​	对内核自身代码的期望是完全不同的。 内核代码被假定是由善意和细心的程序员编写的。 内核代码应该没有错误，当然也不包含任何恶意内容。 这个假设会影响我们分析内核代码的方式。 例如，有许多内部内核函数（例如自旋锁）如果内核代码使用不当会导致严重问题。 在检查任何特定的内核代码时，我们想要说服自己它的行为是正确的。 然而，我们假设内核代码通常是正确编写的，并且遵循关于使用内核自己的函数和数据结构的所有规则。 在硬件层面，假定 RISC-V CPU、RAM、磁盘等按照文档中宣传的方式运行，没有硬件错误。

​	当然，在现实生活中的事情并没有那么简单，很难防止聪明的用户代码通过小号内核保护的资源（磁盘空间、CPU时间、进程表等）使系统无法使用或崩溃。通常不可能编写没有错误的代码，如果恶意用户代码的编写者直到内核或硬件错误，他们就会利用这些漏洞。值得在内核中设计安全措施以防止它有错误的可能性：断言、类型检查、堆栈保护页面等。

2.8 real word

​	大多数操作系统都采用了进程的概念，而且大多数进程看起来与 xv6 的类似。 然而，现代操作系统支持一个进程中的多个线程，以允许单个进程利用多个 CPU。 在一个进程中支持多个线程涉及 xv6 所没有的相当多的机制，包括潜在的接口更改（例如，Linux 的克隆，fork 的变体），以控制进程线程共享的哪些方面。

2.9 experiment

1. 在xv6中添加一个系统调用并返回还有多少可用的内存空间的大小。
