**æ“ä½œç³»ç»Ÿï¼šç³»ç»Ÿç¨‹åºçš„æ‰§è¡Œè€…å’Œä¸­æ–­çš„ç®¡ç†è€…**

#### å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥

ä¸€åˆ‡éƒ½æ˜¯çŠ¶æ€æœºï¼ï¼ï¼

Q:å¦‚ä½•åœ¨å¤šå¤„ç†å™¨ä¸Šå®ç°çº¿ç¨‹äº’æ–¥ï¼Ÿ

è‡ªæ—‹é”å’Œäº’æ–¥é”çš„å®ç°ï¼ï¼ï¼

ç†è§£å¹¶å‘ï¼šçº¿ç¨‹ï¼ˆäººï¼‰ã€å…±äº«å†…å­˜ï¼ˆç‰©ç†ä¸–ç•Œï¼‰

* å¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰ğŸ”’ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„lockä¸èƒ½è¿”å›ã€‚

å®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼šä¸èƒ½åŒæ—¶è¯»/å†™å…±äº«å†…å­˜ã€‚

`load`çš„æ—¶å€™ä¸èƒ½å†™ï¼Œåªèƒ½â€œçœ‹ä¸€çœ¼å°±æŠŠçœ¼ç›é—­ä¸Šâ€ï¼Œçœ‹åˆ°çš„ä¸œè¥¿é©¬ä¸Šå°±è¿‡æ—¶äº†

`store`çš„æ—¶å€™ä¸èƒ½è¯»ï¼Œåªèƒ½â€œé—­ç€çœ¼ç›åŠ¨æ‰‹â€ï¼Œä¹Ÿä¸çŸ¥é“æŠŠä»€ä¹ˆæ”¹æˆäº†ä»€ä¹ˆ

è§£å†³é—®é¢˜çš„ä¸¤ç§æ–¹æ³•ï¼š

1 æå‡ºç®—æ³•ã€è§£å†³é—®é¢˜

2 æ”¹å˜å‡è®¾ï¼ˆè½¯ä»¶ä¸å¤Ÿï¼Œç¡¬ä»¶æ¥å‡‘ï¼‰

å‡è®¾ç¡¬ä»¶èƒ½ä¸ºæˆ‘ä»¬æä¾›ä¸€æ¡â€œç¬æ—¶å®Œæˆâ€çš„è¯»+å†™æŒ‡ä»¤

è¯·æ‰€æœ‰äººé—­ä¸Šçœ¼ç›ã€‚çœ‹ä¸€çœ¼ï¼ˆloadï¼‰ï¼Œç„¶åè´´ä¸Šæ ‡ç­¾ï¼ˆstoreï¼‰

å¦‚æœå¤šäººåŒæ—¶è¯·æ±‚ï¼Œç¡¬ä»¶é€‰å‡ºä¸€ä¸ªâ€œèƒœè€…â€

â€œè´¥è€…â€ç­‰å¾…â€èƒœè€…â€œå®Œæˆåæ‰èƒ½ç»§ç»­

X86åŸå­æ“ä½œï¼š`LOCKæŒ‡ä»¤å‰ç¼€`

```c
//Atomic exchange(load + store)
//ç”¨xchgå®ç°äº’æ–¥
int xchg(volatile int *addr, int newval){
    int result;
    asm volatile("lock xchg %0, %1":"+m"(*addr), "=a"(result):"1"(newval));
    return result;
}
```

å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

```c
int table = YES;
void lock(){
    retry:
    	int got = xchg(&table, NOPE);
    	if(got == NOPE)
            goto retry;
    	assert(got == YES);
}
void unlock(){
    xchg(&table, YES);
}
//--------------------
int locked = 0;
void lock(){while(xchg(&locked, 1));}
void unlock(xchg(&locked, 0);)
```

åŸå­æŒ‡ä»¤çš„æ¨¡å‹ï¼š

ä¿è¯ä¹‹å‰çš„storeéƒ½å†™å…¥å†…å­˜

ä¿è¯load/storeä¸ä¸åŸå­æŒ‡ä»¤ä¹±åº

è‡ªæ—‹é”çš„ç¼ºé™·ï¼š

* è‡ªæ—‹ï¼ˆå…±äº«å˜é‡ï¼‰ä¼šè§¦å‘å¤„ç†å™¨é—´çš„ç¼“å­˜åŒæ­¥ï¼Œå¢åŠ å»¶è¿Ÿ

* é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬

* è·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»

è‡ªæ—‹é”çš„ä½¿ç”¨åœºæ™¯ï¼š

* ä¸´ç•ŒåŒºå‡ ä¹ä¸æ‹¥å µ
* æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢

æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„ï¼ˆçŸ­ä¸´ç•ŒåŒºï¼‰

Futex = Spin + Mutex

è‡ªæ—‹é”ï¼ˆçº¿ç¨‹ç›´æ¥å…±äº«lockedï¼‰

* æ›´å¿«çš„fast path
  * xchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
* æ›´æ…¢çš„slow path
  * xchg å¤±è´¥ â†’æµªè´¹CPUè‡ªæ—‹ç­‰å¾…

ç¡çœ é”ï¼ˆé€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—®lockedï¼‰

* (æ›´å¿«çš„fast path)ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨CPU
* (æ›´æ…¢çš„fast path)å³ä¾¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸ï¼ˆsyscall)

Futexï¼ˆä¸¤è€…å…¼å¾—ï¼‰

* Fast path:ä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œä¸Šé”æˆåŠŸç«‹å³è¿”å›
* Slow path:ä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç¡çœ 

#### å¹¶å‘æ§åˆ¶ï¼šåŒæ­¥

Qï¼šå¦‚ä½•åœ¨å¤šå¤„ç†å™¨ä¸ŠååŒå¤šä¸ªçº¿ç¨‹å®Œæˆä»»åŠ¡ï¼Ÿ

å…¸å‹çš„åŒæ­¥é—®é¢˜ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€å“²å­¦å®¶åƒé¥­

åŒæ­¥çš„å®ç°æ–¹æ³•ï¼šä¿¡å·é‡ã€æ¡ä»¶å˜é‡

çº¿ç¨‹åŒæ­¥ï¼šåœ¨æŸä¸ªæ—¶é—´ç‚¹å…±åŒè¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€

ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ï¼š

```c
void Tproduce(){while(1) printf("(");} //ç”Ÿäº§èµ„æºã€æ”¾å…¥é˜Ÿåˆ—ï¼ŒåµŒå¥—æ·±åº¦ä¸è¶³næ—¶æ‰èƒ½æ‰“å°
void Tconsume(){while(1) printf(")");} //ä»é˜Ÿåˆ—å–å‡ºèµ„æºæ‰§è¡Œï¼ŒåµŒå¥—æ·±åº¦>1æ—¶æ‰èƒ½æ‰“å°
```

åŒæ­¥ï¼šç­‰åˆ°æœ‰ç©ºä½å†æ‰“å°å·¦æ‹¬å·ï¼Œç­‰åˆ°èƒ½é…å¯¹æ—¶å†æ‰“å°å³æ‹¬å·

æ¡ä»¶å˜é‡APIï¼š

* wait(cv, mutex) zZzä¼‘çœ 

è°ƒç”¨æ—¶å¿…é¡»ä¿è¯å·²ç»è·å¾—mutex

é‡Šæ”¾mutexã€è¿›å…¥ä¼‘çœ çŠ¶æ€

* signal/notify(cv)ç§ä¿¡ï¼šèµ°èµ·

å¦‚æœæœ‰çº¿ç¨‹æ­£åœ¨ç­‰å¾…cvï¼Œåˆ™å”¤é†’å…¶ä¸­ä¸€ä¸ªçº¿ç¨‹

* broadcast/notifyAll(cv) æ‰€æœ‰äººï¼šèµ°èµ·

å”¤é†’å…¨éƒ¨æ­£åœ¨ç­‰å¾…cvçš„çº¿ç¨‹

æ¡ä»¶å˜é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…(éœ€è¦ç­‰å¾…æ¡ä»¶å˜é‡æ»¡è¶³)

```c
void Tproduce() {
  mutex_lock(&lk);
  if (count == n) cond_wait(&cv, &lk);
  printf("("); count++; cond_signal(&cv);
  mutex_unlock(&lk);
}

void Tconsume() {
  mutex_lock(&lk);
  if (count == 0) cond_wait(&cv, &lk);
  printf(")"); count--; cond_signal(&cv);
  mutex_unlock(&lk);
}
```

æ¡ä»¶å˜é‡å®ç°å¹¶è¡Œè®¡ç®—

```c
struct job {
  void (*run)(void *arg);
  void *arg;
}

while (1) {
  struct job *job;

  mutex_lock(&mutex);
  while (! (job = get_job()) ) {
    wait(&cv, &mutex);
  }
  mutex_unlock(&mutex);

  job->run(job->arg); // ä¸éœ€è¦æŒæœ‰é”
                      // å¯ä»¥ç”Ÿæˆæ–°çš„ job
                      // æ³¨æ„å›æ”¶åˆ†é…çš„èµ„æº
}
```

ä¿¡å·é‡ï¼šï¼ˆæ›´è¡£å®¤ç®¡ç†ï¼‰

P(&sem) 

* ç­‰å¾…ä¸€ä¸ªæ‰‹ç¯åè¿”å›
* å¦‚æœæ­¤æ—¶ç®¡ç†å‘˜æ‰‹ä¸Šæœ‰ç©ºé—²çš„æ‰‹ç¯ï¼Œç«‹å³è¿”å›

V(&sem)

* å˜å‡ºä¸€ä¸ªæ‰‹ç¯é€ç»™ç®¡ç†å‘˜

ä¿¡å·é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…

```c
void producer() {
  P(&empty);   // P()è¿”å› -> å¾—åˆ°æ‰‹ç¯
  printf("("); // å‡è®¾çº¿ç¨‹å®‰å…¨
  V(&fill);
}
void consumer() {
  P(&fill);
  printf(")");
  V(&empty);
}
```

é¿å…æ­»é”ï¼šé¿å…æ­»é”äº§ç”Ÿçš„å››ä¸ªå¿…è¦æ¡ä»¶ï¼š

* äº’æ–¥ï¼Œä¸€ä¸ªèµ„æºæ¯æ¬¡åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨
* è¯·æ±‚ä¸ä¿æŒï¼Œä¸€ä¸ªè¿›ç¨‹è¯·æ±‚èµ„æºé˜»å¡æ—¶ï¼Œä¸é‡Šæ”¾å·²è·å¾—çš„èµ„æº
* ä¸å‰¥å¤ºï¼Œè¿›ç¨‹ä¸€è·å¾—çš„èµ„æºä¸èƒ½å¼ºè¡Œå‰¥å¤º
* å¾ªç¯ç­‰å¾…ï¼Œè‹¥å¹²è¿›ç¨‹ä¹‹é—´å½¢æˆå¤´å°¾ç›¸æ¥çš„å¾ªç¯ç­‰å¾…èµ„æºå…³ç³»

æ•°æ®ç«äº‰ï¼šä¸åŒçš„çº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€æ®µå†…å­˜ï¼Œä¸”è‡³å°‘ä¸€ä¸ªæ˜¯å†™ã€‚

ï¼ˆb'\xcd' * 80).decode('gb2312')



`gcc -O2 main.c -g`

`gdb a.out`

`strace ./a.out`

`start`

`layout src / layout asm`

`record full `ï¼š è®°å½•æ‰€æœ‰çš„çŠ¶æ€

`record stop`ï¼š ç»“æŸè®°å½•

`p val` ï¼šæŸ¥çœ‹valçš„å€¼

`rsi` ï¼šå›é€€åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€

gdb æ˜¾ç¤º *no source available* :åœ¨ç¼–è¯‘é˜¶æ®µ æ·»åŠ  **-g**é€‰é¡¹

çŠ¶æ€æœºæ¨¡å‹ç†è§£ä¸–ç•Œ

ç¨‹åºæ‰§è¡Œ==çŠ¶æ€æœºæ‰§è¡Œ

strace/gdb

æ“ä½œç³»ç»Ÿçš„å†…æ ¸å¯åŠ¨ï¼šCPU reset -> Firmware -> Boot loader -> Kernel_start() -> ...

é€€å‡ºQEMU  ^a + x



`starti`

`info inferiors`

`pmap process id` ï¼šæŸ¥çœ‹ä¸€ä¸ªè¿›ç¨‹çš„æ‰€æœ‰åœ°å€ç©ºé—´







