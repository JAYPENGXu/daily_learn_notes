**æ“ä½œç³»ç»Ÿï¼šç³»ç»Ÿç¨‹åºçš„æ‰§è¡Œè€…å’Œä¸­æ–­çš„ç®¡ç†è€…**

**æ“ä½œç³»ç»Ÿï¼šçŠ¶æ€æœºçš„ç®¡ç†è€…**

#### å¹¶å‘æ§åˆ¶ï¼šäº’æ–¥

ä¸€åˆ‡éƒ½æ˜¯çŠ¶æ€æœºï¼ï¼ï¼

Q:å¦‚ä½•åœ¨å¤šå¤„ç†å™¨ä¸Šå®ç°çº¿ç¨‹äº’æ–¥ï¼Ÿ

è‡ªæ—‹é”å’Œäº’æ–¥é”çš„å®ç°ï¼ï¼ï¼

ç†è§£å¹¶å‘ï¼šçº¿ç¨‹ï¼ˆäººï¼‰ã€å…±äº«å†…å­˜ï¼ˆç‰©ç†ä¸–ç•Œï¼‰

* å¦‚æœæŸä¸ªçº¿ç¨‹æŒæœ‰ğŸ”’ï¼Œåˆ™å…¶ä»–çº¿ç¨‹çš„lockä¸èƒ½è¿”å›ã€‚

å®ç°äº’æ–¥çš„æ ¹æœ¬å›°éš¾ï¼šä¸èƒ½åŒæ—¶è¯»/å†™å…±äº«å†…å­˜ã€‚

`load`çš„æ—¶å€™ä¸èƒ½å†™ï¼Œåªèƒ½â€œçœ‹ä¸€çœ¼å°±æŠŠçœ¼ç›é—­ä¸Šâ€ï¼Œçœ‹åˆ°çš„ä¸œè¥¿é©¬ä¸Šå°±è¿‡æ—¶äº†

`store`çš„æ—¶å€™ä¸èƒ½è¯»ï¼Œåªèƒ½â€œé—­ç€çœ¼ç›åŠ¨æ‰‹â€ï¼Œä¹Ÿä¸çŸ¥é“æŠŠä»€ä¹ˆæ”¹æˆäº†ä»€ä¹ˆ

è§£å†³é—®é¢˜çš„ä¸¤ç§æ–¹æ³•ï¼š

1 æå‡ºç®—æ³•ã€è§£å†³é—®é¢˜

2 æ”¹å˜å‡è®¾ï¼ˆè½¯ä»¶ä¸å¤Ÿï¼Œç¡¬ä»¶æ¥å‡‘ï¼‰

å‡è®¾ç¡¬ä»¶èƒ½ä¸ºæˆ‘ä»¬æä¾›ä¸€æ¡â€œç¬æ—¶å®Œæˆâ€çš„è¯»+å†™æŒ‡ä»¤

è¯·æ‰€æœ‰äººé—­ä¸Šçœ¼ç›ã€‚çœ‹ä¸€çœ¼ï¼ˆloadï¼‰ï¼Œç„¶åè´´ä¸Šæ ‡ç­¾ï¼ˆstoreï¼‰

å¦‚æœå¤šäººåŒæ—¶è¯·æ±‚ï¼Œç¡¬ä»¶é€‰å‡ºä¸€ä¸ªâ€œèƒœè€…â€

â€œè´¥è€…â€ç­‰å¾…â€èƒœè€…â€œå®Œæˆåæ‰èƒ½ç»§ç»­

X86åŸå­æ“ä½œï¼š`LOCKæŒ‡ä»¤å‰ç¼€`

```c
//Atomic exchange(load + store)
//ç”¨xchgå®ç°äº’æ–¥
int xchg(volatile int *addr, int newval){
    int result;
    asm volatile("lock xchg %0, %1":"+m"(*addr), "=a"(result):"1"(newval));
    return result;
}
```

å®ç°äº’æ–¥ï¼šè‡ªæ—‹é”

```c
int table = YES;
void lock(){
    retry:
    	int got = xchg(&table, NOPE);
    	if(got == NOPE)
            goto retry;
    	assert(got == YES);
}
void unlock(){
    xchg(&table, YES);
}
//--------------------
int locked = 0;
void lock(){while(xchg(&locked, 1));}
void unlock(xchg(&locked, 0);)
```

åŸå­æŒ‡ä»¤çš„æ¨¡å‹ï¼š

ä¿è¯ä¹‹å‰çš„storeéƒ½å†™å…¥å†…å­˜

ä¿è¯load/storeä¸ä¸åŸå­æŒ‡ä»¤ä¹±åº

è‡ªæ—‹é”çš„ç¼ºé™·ï¼š

* è‡ªæ—‹ï¼ˆå…±äº«å˜é‡ï¼‰ä¼šè§¦å‘å¤„ç†å™¨é—´çš„ç¼“å­˜åŒæ­¥ï¼Œå¢åŠ å»¶è¿Ÿ

* é™¤äº†è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹ï¼Œå…¶ä»–å¤„ç†å™¨ä¸Šçš„çº¿ç¨‹éƒ½åœ¨ç©ºè½¬

* è·å¾—è‡ªæ—‹é”çš„çº¿ç¨‹å¯èƒ½è¢«æ“ä½œç³»ç»Ÿåˆ‡æ¢å‡ºå»

è‡ªæ—‹é”çš„ä½¿ç”¨åœºæ™¯ï¼š

* ä¸´ç•ŒåŒºå‡ ä¹ä¸æ‹¥å µ
* æŒæœ‰è‡ªæ—‹é”æ—¶ç¦æ­¢æ‰§è¡Œæµåˆ‡æ¢

æ“ä½œç³»ç»Ÿå†…æ ¸çš„å¹¶å‘æ•°æ®ç»“æ„ï¼ˆçŸ­ä¸´ç•ŒåŒºï¼‰

Futex = Spin + Mutex

è‡ªæ—‹é”ï¼ˆçº¿ç¨‹ç›´æ¥å…±äº«lockedï¼‰

* æ›´å¿«çš„fast path
  * xchg æˆåŠŸ â†’ ç«‹å³è¿›å…¥ä¸´ç•ŒåŒºï¼Œå¼€é”€å¾ˆå°
* æ›´æ…¢çš„slow path
  * xchg å¤±è´¥ â†’æµªè´¹CPUè‡ªæ—‹ç­‰å¾…

ç¡çœ é”ï¼ˆé€šè¿‡ç³»ç»Ÿè°ƒç”¨è®¿é—®lockedï¼‰

* (æ›´å¿«çš„fast path)ä¸Šé”å¤±è´¥çº¿ç¨‹ä¸å†å ç”¨CPU
* (æ›´æ…¢çš„fast path)å³ä¾¿ä¸Šé”æˆåŠŸä¹Ÿéœ€è¦è¿›å‡ºå†…æ ¸ï¼ˆsyscall)

Futexï¼ˆä¸¤è€…å…¼å¾—ï¼‰

* Fast path:ä¸€æ¡åŸå­æŒ‡ä»¤ï¼Œä¸Šé”æˆåŠŸç«‹å³è¿”å›
* Slow path:ä¸Šé”å¤±è´¥ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ç¡çœ 

#### å¹¶å‘æ§åˆ¶ï¼šåŒæ­¥

Qï¼šå¦‚ä½•åœ¨å¤šå¤„ç†å™¨ä¸ŠååŒå¤šä¸ªçº¿ç¨‹å®Œæˆä»»åŠ¡ï¼Ÿ

å…¸å‹çš„åŒæ­¥é—®é¢˜ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ã€å“²å­¦å®¶åƒé¥­

åŒæ­¥çš„å®ç°æ–¹æ³•ï¼šä¿¡å·é‡ã€æ¡ä»¶å˜é‡

çº¿ç¨‹åŒæ­¥ï¼šåœ¨æŸä¸ªæ—¶é—´ç‚¹å…±åŒè¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€

ç”Ÿäº§è€…-æ¶ˆè´¹è€…é—®é¢˜ï¼š

```c
void Tproduce(){while(1) printf("(");} //ç”Ÿäº§èµ„æºã€æ”¾å…¥é˜Ÿåˆ—ï¼ŒåµŒå¥—æ·±åº¦ä¸è¶³næ—¶æ‰èƒ½æ‰“å°
void Tconsume(){while(1) printf(")");} //ä»é˜Ÿåˆ—å–å‡ºèµ„æºæ‰§è¡Œï¼ŒåµŒå¥—æ·±åº¦>1æ—¶æ‰èƒ½æ‰“å°
```

åŒæ­¥ï¼šç­‰åˆ°æœ‰ç©ºä½å†æ‰“å°å·¦æ‹¬å·ï¼Œç­‰åˆ°èƒ½é…å¯¹æ—¶å†æ‰“å°å³æ‹¬å·

æ¡ä»¶å˜é‡APIï¼š

* wait(cv, mutex) zZzä¼‘çœ 

è°ƒç”¨æ—¶å¿…é¡»ä¿è¯å·²ç»è·å¾—mutex

é‡Šæ”¾mutexã€è¿›å…¥ä¼‘çœ çŠ¶æ€

* signal/notify(cv)ç§ä¿¡ï¼šèµ°èµ·

å¦‚æœæœ‰çº¿ç¨‹æ­£åœ¨ç­‰å¾…cvï¼Œåˆ™å”¤é†’å…¶ä¸­ä¸€ä¸ªçº¿ç¨‹

* broadcast/notifyAll(cv) æ‰€æœ‰äººï¼šèµ°èµ·

å”¤é†’å…¨éƒ¨æ­£åœ¨ç­‰å¾…cvçš„çº¿ç¨‹

æ¡ä»¶å˜é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…(éœ€è¦ç­‰å¾…æ¡ä»¶å˜é‡æ»¡è¶³)

```c
void Tproduce() {
  mutex_lock(&lk);
  if (count == n) cond_wait(&cv, &lk);
  printf("("); count++; cond_signal(&cv);
  mutex_unlock(&lk);
}

void Tconsume() {
  mutex_lock(&lk);
  if (count == 0) cond_wait(&cv, &lk);
  printf(")"); count--; cond_signal(&cv);
  mutex_unlock(&lk);
}
```

æ¡ä»¶å˜é‡å®ç°å¹¶è¡Œè®¡ç®—

```c
struct job {
  void (*run)(void *arg);
  void *arg;
}

while (1) {
  struct job *job;

  mutex_lock(&mutex);
  while (! (job = get_job()) ) {
    wait(&cv, &mutex);
  }
  mutex_unlock(&mutex);

  job->run(job->arg); // ä¸éœ€è¦æŒæœ‰é”
                      // å¯ä»¥ç”Ÿæˆæ–°çš„ job
                      // æ³¨æ„å›æ”¶åˆ†é…çš„èµ„æº
}
```

ä¿¡å·é‡ï¼šï¼ˆæ›´è¡£å®¤ç®¡ç†ï¼‰

P(&sem) 

* ç­‰å¾…ä¸€ä¸ªæ‰‹ç¯åè¿”å›
* å¦‚æœæ­¤æ—¶ç®¡ç†å‘˜æ‰‹ä¸Šæœ‰ç©ºé—²çš„æ‰‹ç¯ï¼Œç«‹å³è¿”å›

V(&sem)

* å˜å‡ºä¸€ä¸ªæ‰‹ç¯é€ç»™ç®¡ç†å‘˜

ä¿¡å·é‡å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…

```c
void producer() {
  P(&empty);   // P()è¿”å› -> å¾—åˆ°æ‰‹ç¯
  printf("("); // å‡è®¾çº¿ç¨‹å®‰å…¨
  V(&fill);
}
void consumer() {
  P(&fill);
  printf(")");
  V(&empty);
}
```

é¿å…æ­»é”ï¼šé¿å…æ­»é”äº§ç”Ÿçš„å››ä¸ªå¿…è¦æ¡ä»¶ï¼š

* äº’æ–¥ï¼Œä¸€ä¸ªèµ„æºæ¯æ¬¡åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨
* è¯·æ±‚ä¸ä¿æŒï¼Œä¸€ä¸ªè¿›ç¨‹è¯·æ±‚èµ„æºé˜»å¡æ—¶ï¼Œä¸é‡Šæ”¾å·²è·å¾—çš„èµ„æº
* ä¸å‰¥å¤ºï¼Œè¿›ç¨‹ä¸€è·å¾—çš„èµ„æºä¸èƒ½å¼ºè¡Œå‰¥å¤º
* å¾ªç¯ç­‰å¾…ï¼Œè‹¥å¹²è¿›ç¨‹ä¹‹é—´å½¢æˆå¤´å°¾ç›¸æ¥çš„å¾ªç¯ç­‰å¾…èµ„æºå…³ç³»

æ•°æ®ç«äº‰ï¼šä¸åŒçš„çº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€æ®µå†…å­˜ï¼Œä¸”è‡³å°‘ä¸€ä¸ªæ˜¯å†™ã€‚

ï¼ˆb'\xcd' * 80).decode('gb2312')



`gcc -O2 main.c -g`

`gdb a.out`

`strace ./a.out`

`start`

`layout src / layout asm`

`record full `ï¼š è®°å½•æ‰€æœ‰çš„çŠ¶æ€

`record stop`ï¼š ç»“æŸè®°å½•

`p val` ï¼šæŸ¥çœ‹valçš„å€¼

`rsi` ï¼šå›é€€åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€

gdb æ˜¾ç¤º *no source available* :åœ¨ç¼–è¯‘é˜¶æ®µ æ·»åŠ  **-g**é€‰é¡¹

çŠ¶æ€æœºæ¨¡å‹ç†è§£ä¸–ç•Œ

ç¨‹åºæ‰§è¡Œ==çŠ¶æ€æœºæ‰§è¡Œ

strace/gdb

æ“ä½œç³»ç»Ÿçš„å†…æ ¸å¯åŠ¨ï¼šCPU reset -> Firmware -> Boot loader -> Kernel_start() -> æ‰§è¡Œç¬¬ä¸€ä¸ªç¨‹åº/bin/init -> ä¸­æ–­/å¼‚å¸¸çš„å¤„ç†ç¨‹åº

é€€å‡ºQEMU  ^a + x



`starti`

`info inferiors`

`pmap process id` ï¼šæŸ¥çœ‹ä¸€ä¸ªè¿›ç¨‹çš„æ‰€æœ‰åœ°å€ç©ºé—´

æ“ä½œç³»ç»Ÿä¸Šçš„è¿›ç¨‹

ç¨‹åºï¼šçŠ¶æ€æœº

* Cä»£ç è§†è§’ï¼šè¯­å¥
* æ±‡ç¼–/æœºå™¨ç è§†è§’ï¼šæŒ‡ä»¤
* ä¸æ“ä½œç³»ç»Ÿäº¤äº’çš„æ–¹å¼ï¼šsyscall

è™šæ‹ŸåŒ–ï¼šæ“ä½œç³»ç»Ÿå†ç‰©ç†å†…å­˜ä¸­ä¿å­˜å¤šä¸ªçŠ¶æ€æœº

åˆ›å»ºçŠ¶æ€æœºï¼š fork:åšä¸€ä»½çŠ¶æ€æœºå®Œæ•´çš„å¤åˆ¶ï¼ˆå†…å­˜ï¼Œå¯„å­˜å™¨ç°åœºï¼‰

`int fork();`

* ç«‹å³å¤åˆ¶çŠ¶æ€æœº
* æ–°åˆ›å»ºè¿›ç¨‹è¿”å›0
* æ‰§è¡Œforkçš„è¿›ç¨‹è¿”å›å­è¿›ç¨‹çš„è¿›ç¨‹å·

çŠ¶æ€æœºç®¡ç†ï¼šæ›¿æ¢çŠ¶æ€æœº

`execve()`

* å°†å½“å‰è¿è¡Œçš„çŠ¶æ€æœºé‡ç½®æˆå¦ä¸€ä¸ªç¨‹åºçš„åˆå§‹çŠ¶æ€

`int execve(const char *filename, char * const argv, char *const envp);`

* æ‰§è¡Œåä¸ºfilenameçš„ç¨‹åº
* å…è®¸å¯¹æ–°çŠ¶æ€æœºè®¾ç½®å‚æ•°`argv(v)`å’Œç¯å¢ƒå˜é‡`envp(e)`ï¼Œåˆšå¥½å¯¹åº”äº†`main()`çš„å‚æ•°

`exit()` ç»ˆæ­¢çŠ¶æ€æœº

* ç«‹å³æ‘§æ¯çŠ¶æ€æœº
* é”€æ¯å½“å‰çŠ¶æ€æœºï¼Œå¹¶å…è®¸æœ‰ä¸€ä¸ªè¿”å›å€¼
* å­è¿›ç¨‹ç»ˆæ­¢ä¼šé€šçŸ¥çˆ¶è¿›ç¨‹

ç¯å¢ƒå˜é‡ï¼š

* ä½¿ç”¨`env`å‘½ä»¤æŸ¥çœ‹ `env | grep DISPLAY`
* PATHï¼šå¯æ‰§è¡Œæ–‡ä»¶æœç´¢è·¯å¾„
* PWD
* HOMEï¼šç›®å½•
* DISPLAYï¼šå›¾å½¢è¾“å‡º
* PS1:shellï¼šçš„æç¤ºç¬¦
* exportï¼šå‘Šè¯‰shellå†åˆ›å»ºå­è¿›ç¨‹æ—¶è®¾ç½®ç¯å¢ƒå˜é‡

è¿›ç¨‹çš„åœ°å€ç©ºé—´æ˜¯å¦‚ä½•åˆ›å»ºçš„ï¼Œå¦‚ä½•æ›´æ”¹çš„ï¼Ÿ

è¿›ç¨‹åœ°å€ç©ºé—´çš„ç®¡ç†APIï¼š `mmap`

é™æ€é“¾æ¥ï¼šä»£ç ã€æ•°æ®ã€å †æ ˆã€å †åŒº

åŠ¨æ€é“¾æ¥ï¼šä»£ç ã€æ•°æ®ã€å †æ ˆã€å †åŒºã€`INTERP`

æ•´ä¸ªè®¡ç®—æœºç³»ç»Ÿå¦‚ä½•â€œæ„å»ºâ€ï¼š

1. ç¡¬ä»¶ï¼šä»CPU resetå¼€å§‹æ‰§è¡ŒæŒ‡ä»¤

2. Firmwareï¼šåŠ è½½æ“ä½œç³»ç»Ÿ
3. æ“ä½œç³»ç»Ÿï¼šçŠ¶æ€æœºçš„ç®¡ç†è€…ï¼Œåˆå§‹åŒ–ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨

shell:ç”¨æˆ·èƒ½ç›´æ¥æ“ä½œçš„ç¨‹åºç®¡ç†æ“ä½œç³»ç»Ÿå¯¹è±¡ï¼Œï¼ˆæŠŠç”¨æˆ·æŒ‡ä»¤ç¿»è¯‘æˆç³»ç»Ÿè°ƒç”¨çš„ç¼–ç¨‹è¯­è¨€ï¼‰ã€‚

`man shell` 

å†…æ ¸æä¾›ç³»ç»Ÿè°ƒç”¨ï¼›shellæä¾›ç”¨æˆ·æ¥å£

**`sh-xv6.c`** : a zero-dependency UNIX Shell 

ä¸€ä¸ªåŠŸèƒ½å®Œæ•´çš„shellä½¿ç”¨çš„æ“ä½œç³»ç»Ÿå¯¹è±¡å’ŒAPI

* session, process group, controlling terminal
* æ–‡ä»¶æè¿°ç¬¦ï¼šopen, close, pipe, dup, read, write
* çŠ¶æ€æœºç®¡ç†ï¼šfork, execve, exit, wait, signal, kill, setpgid

Cæ ‡å‡†åº“

libcï¼šçº¯ç²¹çš„è®¡ç®—ï¼›æ–‡ä»¶æè¿°ç¬¦ï¼›æ›´å¤šçš„è¿›ç¨‹/æ“ä½œç³»ç»ŸåŠŸèƒ½ï¼›åœ°å€ç©ºé—´ï¼›æ— æ­¢å¢ƒå°è£…

workloadåˆ†æï¼š

* è¶Šå°çš„å¯¹è±¡åˆ›å»º/åˆ†é…è¶Šé¢‘ç¹
  * å­—ç¬¦ä¸²ã€ä¸´æ—¶å˜é‡ç­‰ï¼Œç”Ÿå­˜å‘¨æœŸå¯é•¿å¯çŸ­
* è¾ƒä¸ºé¢‘ç¹åœ°åˆ†é…ä¸­ç­‰å¤§å°çš„å¯¹è±¡
  * è¾ƒå¤§çš„æ•°ç»„ï¼Œå¤æ‚çš„å¯¹è±¡ï¼Œæ›´é•¿çš„ç”Ÿå­˜å‘¨æœŸ
* ä½é¢‘ç‡çš„å¤§å¯¹è±¡
  * å·¨å¤§çš„å®¹å™¨ï¼Œåˆ†é…å™¨ï¼Œå¾ˆé•¿çš„ç”Ÿå‘½å‘¨æœŸ

malloc , fast and slow

è®¾ç½®ä¸¤å¥—ç³»ç»Ÿï¼š

* fast path ï¼šä½¿æ‰€æœ‰CPUéƒ½èƒ½å¹¶è¡Œçš„ç”³è¯·å†…å­˜
  * æ€§èƒ½æå¥½ã€å¹¶è¡Œåº¦æé«˜ã€è¦†ç›–å¤§éƒ¨åˆ†æƒ…å†µ
  * ä½†æœ‰å°æ¦‚ç‡ä¼šå¤±è´¥
* slow path
  * ä¸åœ¨ä¹é‚£ä¹ˆå¿«
  * ä½†æŠŠå›°éš¾çš„äº‹æƒ…åšå¥½
* fast pathè®¾è®¡
  * çº¿ç¨‹éƒ½äº‹å…ˆç“œåˆ†ä¸€äº›å†…å­˜
  * é»˜è®¤ä»è‡ªå·±çš„é¢†åœ°é‡Œåˆ†é…
    * é™¤äº†å†å¦ä¸€ä¸ªCPUé‡Šæ”¾
  * å¦‚æœè‡ªå·±çš„é¢†åœ°ä¸è¶³ï¼Œå°±ä»å…¨å±€çš„æ± å­é‡Œå€Ÿä¸€ç‚¹

`ls > a.txt` é‡å®šå‘

`ls | wc -l` ç®¡é“

`ls &` åå°

`strace -f ./a.out`

`strace -f ./a.out |& vim -`

`strace -f ./a.out 1 2 3 |& vim -`

:setnowrap

forkçš„åº”ç”¨ï¼š

æ–‡ä»¶æè¿°ç¬¦ï¼šä¸€ä¸ªæŒ‡å‘æ“ä½œç³»ç»Ÿå†…å¯¹è±¡çš„â€œæŒ‡é’ˆâ€

* å¯¹è±¡åªèƒ½é€šè¿‡OSå…è®¸çš„æ–¹å¼è®¿é—®
* ä»0å¼€å§‹ç¼–å·ï¼ˆ0ï¼Œ1ï¼Œ2åˆ†åˆ«æ˜¯stdin, stdout, stderrï¼‰
* å¯ä»¥é€šè¿‡openå–å¾—ï¼Œcloseé‡Šæ”¾ï¼Œdupå¤åˆ¶
* å¯¹äºæ•°æ®æ–‡ä»¶ï¼Œæ–‡ä»¶æè¿°ç¬¦ä¼šè®°ä½ä¸Šæ¬¡è®¿é—®æ–‡ä»¶çš„ä½ç½®
  * write(2,"a", 1); write(3,"b", 1);

 

